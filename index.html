<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>日拱一卒,功不唐捐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="思考">
<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒,功不唐捐">
<meta property="og:url" content="http://yangsui.me/index.html">
<meta property="og:site_name" content="日拱一卒,功不唐捐">
<meta property="og:description" content="思考">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="日拱一卒,功不唐捐">
<meta name="twitter:description" content="思考">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">联系我</a>
        
      </nav>
      <!--

      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yangsui.me"></form>
        </div>

      </nav>
    -->

    </div>
  </div>
</header>

    <section id="main" class="outer">
      <article id="post-hibernate-search-elasticsearch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    <div class="article-meta">
      <a href="/hibernate-search-elasticsearch/" class="article-date">
  <time datetime="2017-02-09T10:17:56.000Z" itemprop="datePublished">2017-02-09</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>近期将 elasticsearch 集成到了系统里面, 做一些记录</p>
<h1 id="jpa-hibernate-search-集成"><a href="#jpa-hibernate-search-集成" class="headerlink" title="jpa hibernate-search 集成"></a>jpa hibernate-search 集成</h1><p>为了让框架能够自动维护索引(创建，更新，删除)，需要手动写一个 AOP 框架，在实体维护的时候同时维护索引。发现 hibernate 官方的  <code>hibernate-search-elasticsearch</code> 已经做了这块儿工作了，开心。</p>
<p>我这里使用的是 JPA 所有的配置如下:</p>
<p>部分 pom.xml 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;properties&gt;</div><div class="line">    &lt;hibernate.core.version&gt;5.1.3.Final&lt;/hibernate.core.version&gt;</div><div class="line">    &lt;hibernate.search.version&gt;5.6.0.Final&lt;/hibernate.search.version&gt;</div><div class="line">    &lt;hibernate.search.elasticsearch.version&gt;5.6.0.Final&lt;/hibernate.search.elasticsearch.version&gt;</div><div class="line">&lt;/properties&gt;</div><div class="line">    </div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hibernate-search-elasticsearch&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;hibernate.search.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;hibernate.search.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>这里有 2 个坑:</p>
<ol>
<li><p>hibernate core 的版本不要太高，如果使用 hibernate 5.2 以上的版本，都会出现和 hibernate search 不相容的错，<a href="https://hibernate.atlassian.net/browse/HSEARCH-2298" target="_blank" rel="external">Hibernate 5.2 is not compatible with any version of hibernate search
</a></p>
</li>
<li><p>必须添加 hibernate search orm 支持，不然无法自动创建索引</p>
</li>
</ol>
<h1 id="实体映射"><a href="#实体映射" class="headerlink" title="实体映射"></a>实体映射</h1>
      
    </div>
    
    
  </div>
  
</article>









    
      <article id="post-同步异步阻塞非阻塞理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/同步异步阻塞非阻塞理解/">阻塞，非阻塞，同步，异步概念理解</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/同步异步阻塞非阻塞理解/" class="article-date">
  <time datetime="2017-02-02T14:26:00.000Z" itemprop="datePublished">2017-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/system/">system</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->
<p>对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。</p>
<p>严重参考并组合了以下几篇文章。</p>
<p><a href="https://segmentfault.com/a/1190000003063859#articleHeader11" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别</a></p>
<p>我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。所以一个 read 操作会尽力两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>在 <strong>UNIX 网络编程卷一</strong> 中列举了五种 I/O 模型。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>linux 下默认的所有的 socket 都是 阻塞的。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639194732.jpg" alt="阻塞型IO"></p>
<p>用户进程调用 recvfrom 这个系统调用。<br>内核执行IO的第一阶段，准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说<strong>数据被拷贝到操作系统内核的缓冲区中是需要一个过程的</strong>。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。</p>
<p>当内核一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除阻塞状态，重新运行。</p>
<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639318890.jpg" alt="非阻塞IO"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</p>
<p>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639787508.jpg" alt="多路复用IO"></p>
<p><strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
</blockquote>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884642241215.jpg" alt="异步IO"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。</p>
<h2 id="几种-I-O-模型总结"><a href="#几种-I-O-模型总结" class="headerlink" title="几种 I/O 模型总结"></a>几种 I/O 模型总结</h2><p>其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884644916573.jpg" alt="IO模型比较1"></p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884649249894.jpg" alt="IO模型比较2"></p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<br>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>我们可以看到，在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884650634750.jpg" alt="IO模型比较3"></p>
<h3 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞 非阻塞"></a>阻塞 非阻塞</h3><p>调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞IO在kernel还准备数据的情况下会立刻返回。</p>
<p>所以：</p>
<p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h3><p>同步和异步关注的是<strong>消息通信机制</strong></p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/">system</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-春节期间读书计划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/春节期间读书计划/">春节读书计划</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/春节期间读书计划/" class="article-date">
  <time datetime="2017-01-26T14:26:00.000Z" itemprop="datePublished">2017-01-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/reading/">reading</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->
<p>难得放假，读读书也是不错的。过年也就这么几天，准备读这几本书。</p>
<ul>
<li>大话处理器:处理器基础知识读本</li>
</ul>
<p>这本到今天已经读完，算是提前完成任务了。作为入门级的读本，本书幽默风趣，真是在适合不过。</p>
<p><img src="https://images-cn.ssl-images-amazon.com/images/I/518xv9USK-L.jpg" alt="大话处理器:处理器基础知识读本"></p>
<ul>
<li>Java并发编程的艺术</li>
</ul>
<p>草草翻了2章，不点到为止，系统化从底层讲起应该算是本书区别于市面上其它书籍的显著特征。</p>
<p><img src="https://images-cn.ssl-images-amazon.com/images/I/41b6tl-PQ8L.jpg" alt="Java并发编程的艺术"></p>
<ul>
<li>实战Java虚拟机:JVM故障诊断与性能优化</li>
</ul>
<p>读过周志明的<a href="https://www.amazon.cn/dp/B00BTCMPKG/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1485362731&amp;sr=1-2&amp;keywords=%E5%91%A8%E5%BF%97%E6%98%8E" target="_blank" rel="external">深入理解Java虚拟机:JVM高级特性与最佳实践(第1版) </a><br>个人感觉，还是葛一鸣写得更加简单明了</p>
<p><img src="https://images-cn.ssl-images-amazon.com/images/I/51hi2W7slDL._SX377_BO1,204,203,200_.jpg" alt="实战Java虚拟机:JVM故障诊断与性能优化"></p>
<p>春节期间的任务就是读书，带娃，串门。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reading/">reading</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-JAVA8-OverView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/JAVA8-OverView/">JAVA 8 学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/JAVA8-OverView/" class="article-date">
  <time datetime="2016-12-10T14:26:00.000Z" itemprop="datePublished">2016-12-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->
<p>最近一周 JAVA8 的学习总结</p>
<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><ul>
<li>Predicate<T></li>
</ul>
<p>方法: <code>boolean test(T t)</code><br>函数描述: <code>T -&gt; boolean</code><br>作用: 传入一个参数，返回一个bool结果<br>特征化原始类型: IntPredicate, LongPredicate, DoublePredicate </p>
<ul>
<li>Consumer<T></li>
</ul>
<p>方法: <code>boolean test(T t)</code><br>函数描述: <code>T -&gt; void</code><br>作用: 传入一个参数，返回一个bool结果<br>特征化原始类型: IntPredicate, LongPredicate, DoublePredicate </p>
<ul>
<li>Function<T, R></li>
</ul>
<p>方法: <code>R apply(T t)</code><br>函数描述: <code>T -&gt; R</code><br>作用: 传入一个参数，返回一个结果<br>特征化原始类型: IntFunction<R>, IntToLongFunction, IntToDoubleFunction, LongFunction<R>, LongToIntFunction, LongToDoubleFunction, DoubleFunction<R>, ToIntFunction<T>, ToLongFunction<T>, ToDoubleFunction<T></p>
<ul>
<li>Supplier<T></li>
</ul>
<p>方法: <code>T get()</code><br>函数描述: <code>() -&gt; T</code><br>作用: 无参数传入，返回一个结果<br>特征化原始类型: BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier </p>
        
          <p class="article-more-link">
            <a href="/JAVA8-OverView/#more">更多</a>
          </p>
        
      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-位运算的作用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/位运算的作用/">位移运算与运算的基本作用</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/位运算的作用/" class="article-date">
  <time datetime="2016-12-10T14:26:00.000Z" itemprop="datePublished">2016-12-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看了很多底层代码，大量使用到了基础的位移，与运算等，做一个总结。</p>
<h1 id="位移与运算基础知识"><a href="#位移与运算基础知识" class="headerlink" title="位移与运算基础知识"></a>位移与运算基础知识</h1><ol>
<li><p>数字在计算机中是以 补码 的形式保存的；正数的原码，补码，反码相同；负数的补码是原码取反加 1 得到的</p>
</li>
<li><p>位移操作涉及到类型转换</p>
</li>
</ol>
<p>假设有 <code>x &lt;&lt; n</code></p>
<ul>
<li><p>x 是  byte short char int long 基本类型, n 只能是 int 类型</p>
</li>
<li><p>若 x 是 byte short char 类型，首先将类型转化为 int 然后才进行位移操作</p>
</li>
<li><p>若 x 是 byte short char int 类型，那么 n 会被重新赋值，计算方法是 n % 32，可以理解为超过如果 n 超过 32 进行取模</p>
<p>   取 n 的补码的低 5 位， 然后转换为十进制的 int 值，相当于对 n 取 32 模： n = n % 32</p>
<p>   为什么是 5，int 占用 32 位，刚好是 2 的 5 次方</p>
</li>
<li><p>若 x 是 long 类型，取 n 的补码的低 6 位， 计算 n 的方法是 n % 64</p>
</li>
<li><p>double float 类型不能进行移位运算 </p>
</li>
</ul>
<ol>
<li>左移运算 &lt;&lt;</li>
</ol>
<p>按照二进制方式将所有的数字向左移动对应的位数，高位舍弃，低位补 0 ；左移有可能导致溢出。</p>
<p>数学意义：在没有溢出的情况下，对于 正数 和 负数， 左移一位相当于乘以 2 的 1 次方，移动 n 位相当于乘以 2 的 n 次方。</p>
<ol>
<li>有符号右移运算 &gt;&gt;<br>按照二进制形式把所有的数字向右移动对应的位数，低位舍弃，高位的空位补符号位，即正数补 <strong>0</strong> ，负数补 <strong>1</strong></li>
</ol>
<p>数学意义：右移一位相当于除以 2 ，右移 n 位相当于除以 2 的 n 次方， 取商，不要余数。</p>
<ol>
<li>无符号右移运算 &gt;&gt;&gt;<br>按照二进制方式把所有的数字向右移动对应位数，低位舍弃，高位空位补 <strong>0</strong></li>
</ol>
        
          <p class="article-more-link">
            <a href="/位运算的作用/#more">更多</a>
          </p>
        
      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-time" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/time/">珍惜好每一刻</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/time/" class="article-date">
  <time datetime="2016-11-25T00:50:35.000Z" itemprop="datePublished">2016-11-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>加油!</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14800350354012.jpg" alt=""></p>

      
    </div>
    
    
  </div>
  
</article>









    
      <article id="post-JAVA基础--数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/JAVA基础--数据结构/">java 基础 ----基本数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/JAVA基础--数据结构/" class="article-date">
  <time datetime="2016-11-20T06:06:00.000Z" itemprop="datePublished">2016-11-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>字符型(char)</li>
</ul>
<p>java 采用 unicode 编码， 使用 2 个字节表示一个字符，所以java中的一个字符是 <code>2 个字节</code><br>c 语言使用的是 ASCII 编码，一个 char 占用 1 个字节。</p>
<p>由于是无符号的，且 2 个字节 32 位长度，那么其范围是 0 到 65535 。</p>
<ul>
<li><p>布尔类型: boolean</p>
</li>
<li><p>数值类型: 有符号数值类型，最高位表示符号位<br>  byte : 1 字节<br>  short : 2 字节<br>  int : 4 字节<br>  long : 8 字节<br>  float : 4 字节<br>  double : 8 字节</p>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/JAVA基础--数据结构/#more">更多</a>
          </p>
        
      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-tmux基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/tmux基础/">编辑器之 tmux</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/tmux基础/" class="article-date">
  <time datetime="2016-11-11T06:06:00.000Z" itemprop="datePublished">2016-11-11</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>mac 上安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install tmux</div></pre></td></tr></table></figure>
<p>需要使用的时候只需要在命令行输入  <code>tmux</code><br>tmux 所有的操作都带了一个 prefix , 这也是 tmux 用起来比较麻烦的地方. 默认的 prefix 是 <code>ctrl + b</code></p>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>直接在终端查看 session 相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmux ls 列出会话</div><div class="line">tmux attach -t session 进入某个会话</div><div class="line">tmux -r 连接上个断开的session</div><div class="line">tmux new -s session -d 在后台建立会话</div></pre></td></tr></table></figure>
<p>进入 tmux 后查看 session 相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctrl+b s 查看/切换session</div><div class="line">ctrl+b d 离开(detach)session</div><div class="line">ctrl+b $ 重命名当前session</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/tmux基础/#more">更多</a>
          </p>
        
      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tmux/">tmux</a></li></ul>

      </footer>
    
  </div>
  
</article>









    
      <article id="post-2016-11-10-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016-11-10-2/">JAVA ClassLoader</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016-11-10-2/" class="article-date">
  <time datetime="2016-11-10T14:22:22.000Z" itemprop="datePublished">2016-11-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java-类加载器概述"><a href="#java-类加载器概述" class="headerlink" title="java 类加载器概述"></a>java 类加载器概述</h1><p>要使用一个类必须要先将这个类加载到内存中, JVM 将编译后的字节码文件, 即 <code>.class</code> 文件加载到内存中, 并生成一个 <code>java.lang.Class</code> 对象.</p>
<p>字节码文件通常有一下来源:</p>
<ul>
<li>本地磁盘文件系统 class 文件</li>
<li>JAR 包中加载 class 文件</li>
<li>网络地址加载 class 文件</li>
<li>动态编译一个 java 源文件, 并执行加载</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>java 中的类加载器是通过双亲委派模型来实现的, 有如下特点</p>
<ul>
<li><p>类的加载过程采用委托模式实现. 某个特定的类加载器在接到加载类的请求时, 首先将加载任务委托给父类加载器, 依次递归, 如果父类加载器可以完成类加载任务, 就成功返回; 只有父类加载器无法完成此加载任务时, 才自己去加载.</p>
</li>
<li><p>JVM 预定义了三种类加载器</p>
<ul>
<li>根类加载器(Bootstrap ClassLoader). 由C++实现, 负责将<code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中, 如 rt.jar</li>
<li>扩展类加载器(Extension ClassLoader). 负责将 <code>&lt;Java_Runtime_Home &gt;/lib/ext</code> 或者由系统变量 java.ext.dir指定位置中的类库加载到内存中. 开发者可以直接使用标准扩展类加载器.</li>
<li>系统类加载器(System ClassLoader). 负责将系统类路径（CLASSPATH）中指定的类库加载到内存中. 开发者可以直接使用系统类加载器。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>









    
      <article id="post-2016-11-10-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016-11-10-1/">linux 基础命令</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016-11-10-1/" class="article-date">
  <time datetime="2016-11-10T10:54:01.000Z" itemprop="datePublished">2016-11-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1>
      
    </div>
    
    
  </div>
  
</article>









    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 yangsui&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>