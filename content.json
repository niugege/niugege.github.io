{"meta":{"title":"日拱一卒,功不唐捐","subtitle":"日拱一卒,功不唐捐","description":"思考","author":"yangsui","url":"http://yangsui.me"},"pages":[{"title":"Categories","date":"2016-12-02T14:35:46.000Z","updated":"2016-09-11T15:55:19.000Z","comments":true,"path":"categories/index.html","permalink":"http://yangsui.me/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-02T14:40:42.000Z","updated":"2016-12-02T14:40:42.000Z","comments":true,"path":"about/index.html","permalink":"http://yangsui.me/about/index.html","excerpt":"","text":"闭关修炼中，欢迎交流 ^_^ yangsui.forward@gmail.com"},{"title":"Tags","date":"2016-12-02T14:35:46.000Z","updated":"2016-09-11T15:55:19.000Z","comments":true,"path":"tags/index.html","permalink":"http://yangsui.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"upgrade-nojs","date":"2017-05-05T11:13:27.000Z","updated":"2017-05-05T11:19:08.000Z","comments":true,"path":"upgrade-nojs/","link":"","permalink":"http://yangsui.me/upgrade-nojs/","excerpt":"","text":"node 的 n 模块可以升级版本，不错 1234567891011121314# 安装 n 模块$ sudo npm install -g n# 选择一个流行版本安装$ sudo n v6.10.3 # 自动安装最新的稳定版本$ sudo n stable # 查看所有node版本$ sudo n ls# 查看Node的版本，检查升级是否成功$ node -v","categories":[],"tags":[]},{"title":"","slug":"python-hard-way","date":"2017-05-04T12:38:44.000Z","updated":"2017-05-04T13:15:26.000Z","comments":true,"path":"python-hard-way/","link":"","permalink":"http://yangsui.me/python-hard-way/","excerpt":"","text":"虽然是本在简单不过的书，还是会发现自己的错误，所以实践才是王道。 字符串替换中 %s $r 的区别 stackoverflow 上曾经有人问过 what’s the meaning of %r in python 回答得很清楚 123456789101112131415161718192021222324252627282930313233Background:In Python, there are two builtin functions for turning an object into a string: str vs. repr. str is supposed to be a friendly, human readable string. repr is supposed to include detailed information about an object's contents (sometimes, they'll return the same thing, such as for integers). By convention, if there's a Python expression that will eval to another object that's ==, repr will return such an expression e.g.&gt;&gt;&gt; print repr('hi')'hi' # notice the quotes here as opposed to...&gt;&gt;&gt; print str('hi')hiIf returning an expression doesn't make sense for an object, repr should return a string that's surrounded by &lt; and &gt; symbols e.g. &lt;blah&gt;.To answer your original question:%s &lt;-&gt; str%r &lt;-&gt; reprIn addition:You can control the way an instance of your own classes convert to strings by implementing __str__ and __repr__ methods.class Foo: def __init__(self, foo): self.foo = foo def __eq__(self, other): \"\"\"Implements ==.\"\"\" return self.foo == other.foo def __repr__(self): # if you eval the return value of this function, # you'll get another Foo instance that's == to self return \"Foo(%r)\" % self.foo 查看 python str() 的文档也说得很清楚： 123Return a string containing a nicely printable representation of an object. For strings, this returns the string itself. The difference with repr(object) is that str(object) does not always attempt to return a string that is acceptable to eval(); its goal is to return a printable string. If no argument is given, returns the empty string, ''.For more information on strings see Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange which describes sequence functionality (strings are sequences), and also the string-specific methods described in the String Methods section. To output formatted strings use template strings or the % operator described in the String Formatting Operations section. In addition see the String Services section. See also unicode(). 简言之：%s 使用 str() 函数格式化字符串，只返回这个字符串本身。 %r 使用 repr() 函数，可能会返回对象额外的信息。由于调试非常的方便。 pydoc 命令 以前没注意，居然可以直接在命令行使用 pydoc 命令，真是方便啊。 打发打发","categories":[],"tags":[]},{"title":"","slug":"vim-python-ide","date":"2017-05-03T14:00:47.000Z","updated":"2017-05-04T05:34:45.000Z","comments":true,"path":"vim-python-ide/","link":"","permalink":"http://yangsui.me/vim-python-ide/","excerpt":"","text":"记录下python vim 的搭建，以备以后查询方便 vim 安装我使用的是mac，直接使用brew安装，一键搞定 brew install vim 安装之后查看安装结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vim --version~ vim --versionVIM - Vi IMproved 8.0 (2016 Sep 12, compiled May 2 2017 03:55:34)MacOS X (unix) versionIncluded patches: 1-596Compiled by HomebrewHuge version without GUI. Features included (+) or not (-):+acl +file_in_path +mouse_sgr +tag_old_static+arabic +find_in_path -mouse_sysmouse -tag_any_white+autocmd +float +mouse_urxvt -tcl-balloon_eval +folding +mouse_xterm +termguicolors-browse -footer +multi_byte +terminfo++builtin_terms +fork() +multi_lang +termresponse+byte_offset -gettext -mzscheme +textobjects+channel -hangul_input +netbeans_intg +timers+cindent +iconv +num64 +title-clientserver +insert_expand +packages -toolbar+clipboard +job +path_extra +user_commands+cmdline_compl +jumplist +perl +vertsplit+cmdline_hist +keymap +persistent_undo +virtualedit+cmdline_info +lambda +postscript +visual+comments +langmap +printer +visualextra+conceal +libcall +profile +viminfo+cryptv +linebreak +python +vreplace+cscope +lispindent -python3 +wildignore+cursorbind +listcmds +quickfix +wildmenu+cursorshape +localmap +reltime +windows+dialog_con -lua +rightleft +writebackup+diff +menu +ruby -X11+digraphs +mksession +scrollbind -xfontset-dnd +modify_fname +signs -xim-ebcdic +mouse +smartindent -xpm+emacs_tags -mouseshape +startuptime -xsmp+eval +mouse_dec +statusline -xterm_clipboard+ex_extra -mouse_gpm -sun_workshop -xterm_save+extra_search -mouse_jsbterm +syntax+farsi +mouse_netterm +tag_binary system vimrc file: \"$VIM/vimrc\" user vimrc file: \"$HOME/.vimrc\" 2nd user vimrc file: \"~/.vim/vimrc\" user exrc file: \"$HOME/.exrc\" defaults file: \"$VIMRUNTIME/defaults.vim\" fall-back for $VIM: \"/usr/local/share/vim\"Compilation: clang -c -I. -Iproto -DHAVE_CONFIG_H -DMACOS_X_UNIX -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1Linking: clang -L. -fstack-protector -L/usr/local/lib -L/usr/local/opt/libyaml/lib -L/usr/local/opt/openssl/lib -L/usr/local/opt/readline/lib -L/usr/local/lib -o vim -lncurses -liconv -framework Cocoa -mmacosx-version-min=10.12 -fstack-protector-strong -L/usr/local/lib -L/usr/local/Cellar/perl/5.24.1/lib/perl5/5.24.1/darwin-thread-multi-2level/CORE -lperl -lm -lutil -lc -F/usr/local/opt/python/ vim 配置由 vim --version 可以看到相关的配置信息 123456system vimrc file: &quot;$VIM/vimrc&quot; user vimrc file: &quot;$HOME/.vimrc&quot; 2nd user vimrc file: &quot;~/.vim/vimrc&quot; user exrc file: &quot;$HOME/.exrc&quot; defaults file: &quot;$VIMRUNTIME/defaults.vim&quot; fall-back for $VIM: &quot;/usr/local/share/vim&quot; 在用户的根目录下创建 .vimrc 配置文件，所有的配置信息都放到里面 基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879\"开启语法高亮syntax enablecolorscheme solarizedset number\"隐藏顶部标签栏set nocompatible\"隐藏滚动条\"set guioptions-=rset guioptions-=Lset guioptions-=bset guifont=Monaco:h13\"隐藏顶部标签栏set showtabline=0\"字体set guifont=Source\\ Code\\ Pro\\ for\\ Powerline:h13\"solarized主题设置在终端下的设置let g:solarized_termcolors=256\"设置背景色set background=dark\"设置不折行set nowrap\"设置以unix的格式保存文件set fileformat=unix\"设置C样式的缩进格式set cindent\"设置table长度set tabstop=4\"同上set shiftwidth=4\"显示匹配的括号set showmatch\"距离顶部和底部5行set scrolloff=5\"命令行为两行set laststatus=2\"文件编码set fenc=utf-8set backspace=2\"启用鼠标set mouse=aset matchtime=5\"忽略大小写set ignorecaseset incsearch\"高亮搜索项set hlsearch\"不允许扩展tableset noexpandtab\"文件修改之后自动读入set autoreadset whichwrap+=&lt;,&gt;,h,l\"突出显示当前行set cursorline\"突出显示当前列set cursorcolumn 主题我这里使用的是 solarized 我不大愿意在安装 Pathogen 所以采用的是第一种暴力安装方式 123git clone git://github.com/altercation/solarized.gitcp solarized/vim-colors-solarized/colors/solarized.vim ~/.vim/colors 在 vimrc 中使用 solarized 主题 123456789syntax enableif has('gui_running') set background=lightelse set background=darkendifcolorscheme solarized 也可以不用 if 判断，直接使用一种主题 插件配置123456789101112131415161718192021222324252627\" Vundle 设置开始filetype off\" 启用vundle来管理vim插件set rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()\" 安装插件写在这之后Plugin 'VundleVim/Vundle.vim'Plugin 'Valloric/YouCompleteMe'Plugin 'Lokaltog/vim-powerline'Plugin 'scrooloose/nerdtree'Plugin 'Yggdroot/indentLine'Plugin 'jiangmiao/auto-pairs'Plugin 'tell-k/vim-autopep8'Plugin 'scrooloose/nerdcommenter'\" 安装插件写在这之前call vundle#end()filetype plugin indent on\" 常用命令\" :PluginList - 查看已经安装的插件\" :PluginInstall - 安装插件\" :PluginUpdate - 更新插件\" :PluginSearch - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件\" :PluginClean - 删除插件，把安装插件对应行删除，然后执行这个命令即可\" h: vundle - 获取帮助\" vundle的配置到此结束，下面是你自己的配置 添加完 .vimrc之后，保存退出vim，重启 vim, 输入 :PluginInstall 安装插件 vim-powerline 插件配置you-complete-me 插件配置安装这里有一个需要注意的地方，我们在 .vimrc 中配置了 Plugin &#39;Valloric/YouCompleteMe&#39; ， 使用 :PluginInstall 安装的时候，发现一直卡到 YouCompleteMe 这里，到 vundle 下去看，发现其实已经下载完成了只是在等待安装。我的建议是：可以最后安装这个插件，这个插件还要下在 CLang也比较慢。 安装比较简单 12cd ~/.vim/bundle/YouCompleteMe./install --clang-completer 只是在下载 clang 的时候需要耐心等待下。 查找并复制配置文件安装完成之后，需要查找一个名为 .ycm_extra_conf.py 的隐藏文件，这个文件在很多目录下都有，我是复制的~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py 这个目录下的 可以使用 find 命令查找下： 12345678910111213141516YouCompleteMe (master) ✔ sudo find /Users/yangsui/.vim/bundle/YouCompleteMe -name &apos;.*&apos; -print | grep ycm_extra_conf/Users/yangsui/.vim/bundle/YouCompleteMe/python/ycm/tests/testdata/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/clang/testdata/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/clang/testdata/client_data/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/clang/testdata/general_fallback/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/clang/testdata/noflags/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/clang/testdata/test-include/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/cs/testdata/testy-multiple-solutions/solution-not-named-like-folder/extra-conf-abs/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/cs/testdata/testy-multiple-solutions/solution-not-named-like-folder/extra-conf-bad/testy/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/cs/testdata/testy-multiple-solutions/solution-not-named-like-folder/extra-conf-rel/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/testdata/client/.ycm_extra_conf.py/Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/tests/testdata/extra_conf/project/.ycm_extra_conf.py➜ YouCompleteMe (master) ✔ vim /Users/yangsui/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py 在vim启动后，YCM会找寻当前路径以及上层路径的.ycm_extra_conf.py在 ~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py 中提供了默认的模板。也可以参考我的(就在模板上改改而已)。不过这个解决了标准库提示找不到的问题. 一般来说,我会在根目录目录下放一个默认的模板，而后再根据不同的项目在当前目录下再拷贝个.ycm_extra_conf.py. 配置vimrc123456789101112131415161718192021222324252627282930313233343536373839404142\"默认配置文件路径\"let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'\"打开vim时不再询问是否加载ycm_extra_conf.py配置\"let g:ycm_confirm_extra_conf=0set completeopt=longest,menu\"python解释器路径\"let g:ycm_path_to_python_interpreter='/usr/local/bin/python'\"是否开启语义补全\"let g:ycm_seed_identifiers_with_syntax=1\"是否在注释中也开启补全\"let g:ycm_complete_in_comments=1let g:ycm_collect_identifiers_from_comments_and_strings = 0\"开始补全的字符数\"let g:ycm_min_num_of_chars_for_completion=2\"补全后自动关机预览窗口\"let g:ycm_autoclose_preview_window_after_completion=1\" 禁止缓存匹配项,每次都重新生成匹配项\"let g:ycm_cache_omnifunc=0\"字符串中也开启补全\"let g:ycm_complete_in_strings = 1\"离开插入模式后自动关闭预览窗口\"autocmd InsertLeave * if pumvisible() == 0|pclose|endif\"回车即选中当前项\"inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? '&lt;C-y&gt;' : '\\&lt;CR&gt;' \"上下左右键行为\"inoremap &lt;expr&gt; &lt;Down&gt; pumvisible() ? '\\&lt;C-n&gt;' : '\\&lt;Down&gt;'inoremap &lt;expr&gt; &lt;Up&gt; pumvisible() ? '\\&lt;C-p&gt;' : '\\&lt;Up&gt;'inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? '\\&lt;PageDown&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;' : '\\&lt;PageDown&gt;'inoremap &lt;expr&gt; &lt;PageUp&gt; pumvisible() ? '\\&lt;PageUp&gt;\\&lt;C-p&gt;\\&lt;C-n&gt;' : '\\&lt;PageUp&gt;'","categories":[],"tags":[]},{"title":"阻塞，非阻塞，同步，异步概念理解","slug":"同步异步阻塞非阻塞理解","date":"2017-02-02T14:26:00.000Z","updated":"2017-03-02T15:12:05.000Z","comments":true,"path":"同步异步阻塞非阻塞理解/","link":"","permalink":"http://yangsui.me/同步异步阻塞非阻塞理解/","excerpt":"对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。 严重参考并组合了以下几篇文章。 Linux IO模式及 select、poll、epoll详解 怎样理解阻塞非阻塞与同步异步的区别 我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。所以一个 read 操作会尽力两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 在 UNIX 网络编程卷一 中列举了五种 I/O 模型。 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） I/O 多路复用（ IO multiplexing） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO）","text":"对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。 严重参考并组合了以下几篇文章。 Linux IO模式及 select、poll、epoll详解 怎样理解阻塞非阻塞与同步异步的区别 我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。所以一个 read 操作会尽力两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 在 UNIX 网络编程卷一 中列举了五种 I/O 模型。 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） I/O 多路复用（ IO multiplexing） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO） 阻塞 I/O（blocking IO）linux 下默认的所有的 socket 都是 阻塞的。 用户进程调用 recvfrom 这个系统调用。内核执行IO的第一阶段，准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。 当内核一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除阻塞状态，重新运行。 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 非阻塞 I/O（nonblocking IO）linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。 I/O 多路复用（ IO multiplexing）IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 异步 I/O（asynchronous IO） 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。 几种 I/O 模型总结其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。 通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 我们可以看到，在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。 阻塞 非阻塞调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞IO在kernel还准备数据的情况下会立刻返回。 所以： 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 同步 异步同步和异步关注的是消息通信机制 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。","categories":[{"name":"system","slug":"system","permalink":"http://yangsui.me/categories/system/"}],"tags":[{"name":"system","slug":"system","permalink":"http://yangsui.me/tags/system/"}]},{"title":"hibernate-search-elasticsearch 集成","slug":"hibernate-search-elasticsearch","date":"2017-02-02T14:26:00.000Z","updated":"2017-03-02T15:13:02.000Z","comments":true,"path":"hibernate-search-elasticsearch/","link":"","permalink":"http://yangsui.me/hibernate-search-elasticsearch/","excerpt":"","text":"近期将 elasticsearch 集成到了系统里面, 做一些记录 jpa hibernate-search 集成为了让框架能够自动维护索引(创建，更新，删除)，需要手动写一个 AOP 框架，在实体维护的时候同时维护索引。发现 hibernate 官方的 hibernate-search-elasticsearch 已经做了这块儿工作了，开心。 我这里使用的是 JPA 所有的配置如下: 部分 pom.xml 配置 1234567891011121314151617&lt;properties&gt; &lt;hibernate.core.version&gt;5.1.3.Final&lt;/hibernate.core.version&gt; &lt;hibernate.search.version&gt;5.6.0.Final&lt;/hibernate.search.version&gt; &lt;hibernate.search.elasticsearch.version&gt;5.6.0.Final&lt;/hibernate.search.elasticsearch.version&gt;&lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-search-elasticsearch&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.search.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.search.version&#125;&lt;/version&gt;&lt;/dependency&gt; 这里有 2 个坑: hibernate core 的版本不要太高，如果使用 hibernate 5.2 以上的版本，都会出现和 hibernate search 不相容的错，Hibernate 5.2 is not compatible with any version of hibernate search 必须添加 hibernate search orm 支持，不然无法自动创建索引 实体映射","categories":[{"name":"java","slug":"java","permalink":"http://yangsui.me/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yangsui.me/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"http://yangsui.me/tags/hibernate/"},{"name":"search","slug":"search","permalink":"http://yangsui.me/tags/search/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yangsui.me/tags/elasticsearch/"}]},{"title":"春节读书计划","slug":"春节期间读书计划","date":"2017-01-26T14:26:00.000Z","updated":"2017-01-25T16:48:44.000Z","comments":true,"path":"春节期间读书计划/","link":"","permalink":"http://yangsui.me/春节期间读书计划/","excerpt":"","text":"难得放假，读读书也是不错的。过年也就这么几天，准备读这几本书。 大话处理器:处理器基础知识读本 这本到今天已经读完，算是提前完成任务了。作为入门级的读本，本书幽默风趣，真是在适合不过。 Java并发编程的艺术 草草翻了2章，不点到为止，系统化从底层讲起应该算是本书区别于市面上其它书籍的显著特征。 实战Java虚拟机:JVM故障诊断与性能优化 读过周志明的深入理解Java虚拟机:JVM高级特性与最佳实践(第1版) 个人感觉，还是葛一鸣写得更加简单明了 春节期间的任务就是读书，带娃，串门。","categories":[{"name":"reading","slug":"reading","permalink":"http://yangsui.me/categories/reading/"}],"tags":[{"name":"reading","slug":"reading","permalink":"http://yangsui.me/tags/reading/"}]},{"title":"位移运算与运算的基本作用","slug":"位运算的作用","date":"2016-12-10T14:26:00.000Z","updated":"2017-01-22T06:57:37.000Z","comments":true,"path":"位运算的作用/","link":"","permalink":"http://yangsui.me/位运算的作用/","excerpt":"最近看了很多底层代码，大量使用到了基础的位移，与运算等，做一个总结。 位移与运算基础知识 数字在计算机中是以 补码 的形式保存的；正数的原码，补码，反码相同；负数的补码是原码取反加 1 得到的 位移操作涉及到类型转换 假设有 x &lt;&lt; n x 是 byte short char int long 基本类型, n 只能是 int 类型 若 x 是 byte short char 类型，首先将类型转化为 int 然后才进行位移操作 若 x 是 byte short char int 类型，那么 n 会被重新赋值，计算方法是 n % 32，可以理解为超过如果 n 超过 32 进行取模 取 n 的补码的低 5 位， 然后转换为十进制的 int 值，相当于对 n 取 32 模： n = n % 32 为什么是 5，int 占用 32 位，刚好是 2 的 5 次方 若 x 是 long 类型，取 n 的补码的低 6 位， 计算 n 的方法是 n % 64 double float 类型不能进行移位运算 左移运算 &lt;&lt; 按照二进制方式将所有的数字向左移动对应的位数，高位舍弃，低位补 0 ；左移有可能导致溢出。 数学意义：在没有溢出的情况下，对于 正数 和 负数， 左移一位相当于乘以 2 的 1 次方，移动 n 位相当于乘以 2 的 n 次方。 有符号右移运算 &gt;&gt;按照二进制形式把所有的数字向右移动对应的位数，低位舍弃，高位的空位补符号位，即正数补 0 ，负数补 1 数学意义：右移一位相当于除以 2 ，右移 n 位相当于除以 2 的 n 次方， 取商，不要余数。 无符号右移运算 &gt;&gt;&gt;按照二进制方式把所有的数字向右移动对应位数，低位舍弃，高位空位补 0","text":"最近看了很多底层代码，大量使用到了基础的位移，与运算等，做一个总结。 位移与运算基础知识 数字在计算机中是以 补码 的形式保存的；正数的原码，补码，反码相同；负数的补码是原码取反加 1 得到的 位移操作涉及到类型转换 假设有 x &lt;&lt; n x 是 byte short char int long 基本类型, n 只能是 int 类型 若 x 是 byte short char 类型，首先将类型转化为 int 然后才进行位移操作 若 x 是 byte short char int 类型，那么 n 会被重新赋值，计算方法是 n % 32，可以理解为超过如果 n 超过 32 进行取模 取 n 的补码的低 5 位， 然后转换为十进制的 int 值，相当于对 n 取 32 模： n = n % 32 为什么是 5，int 占用 32 位，刚好是 2 的 5 次方 若 x 是 long 类型，取 n 的补码的低 6 位， 计算 n 的方法是 n % 64 double float 类型不能进行移位运算 左移运算 &lt;&lt; 按照二进制方式将所有的数字向左移动对应的位数，高位舍弃，低位补 0 ；左移有可能导致溢出。 数学意义：在没有溢出的情况下，对于 正数 和 负数， 左移一位相当于乘以 2 的 1 次方，移动 n 位相当于乘以 2 的 n 次方。 有符号右移运算 &gt;&gt;按照二进制形式把所有的数字向右移动对应的位数，低位舍弃，高位的空位补符号位，即正数补 0 ，负数补 1 数学意义：右移一位相当于除以 2 ，右移 n 位相当于除以 2 的 n 次方， 取商，不要余数。 无符号右移运算 &gt;&gt;&gt;按照二进制方式把所有的数字向右移动对应位数，低位舍弃，高位空位补 0 与运算的作用 对特定位清0如将一个数的高 8 位清0，那么只需要 a &amp; 0x00FF，高 8 位全是0，进行与运算后清0。 取某数中指定位如有一个二进制数 011001， 我要取该数的第三位，只需要创造一个第三位为 1，其余位为 0 的数字即可。 截取二进制中部分进行内容我需要将一个 int 的 32 位分别装到 4 个 byte 中，采用高位在前，低位在后的方式。 12345678910111213141516/** * 1. 将 int 的 32 位，分别装到 byte 的 4 个字节中去 * 2. 高位在前，低位在后分别装载这 4 个字节的内容 * @param number * @return */private static byte[] intToBytes(final int number) &#123; byte[] result = new byte[4]; result[0] = (byte) ((number &gt;&gt; 24) &amp; 0xFF); result[1] = (byte) ((number &gt;&gt; 16) &amp; 0xFF); result[2] = (byte) ((number &gt;&gt; 8) &amp; 0xFF); result[3] = (byte) (number &amp; 0xFF); return result;&#125; 这里假设 int 的值为十进制的 10，计算过程如下： int int&gt;&gt;24 (int&gt;&gt;24) &amp; 0xFF (byte)((int&gt;&gt;24)&amp;0xFF) 00000000 00000000 00000000 00001010 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000 由于 0xFF 的低 8 位全为 1，所以进行与运算之后，可以保证，原数值的低 8 位不变，最终强制转换为 byte 类型，只保留低 8 位，截去高 24 位，这样就达到了获取一个 int 值的部分二进制位内容的目标。 反之，将一个 4 字节的 byte 数组的 32 位， 分别装到 int 的 32 位中去。 1234567891011121314/** * 高位在前，低位在后 * @param numbers * @return */private static int bytesToInt(final byte[] numbers)&#123; int a = (numbers[0] &amp; 0xFF) &lt;&lt; 24; int b = (numbers[1] &amp; 0xFF) &lt;&lt; 16; int c = (numbers[2] &amp; 0xFF) &lt;&lt; 8; int d = (numbers[3] &amp; 0xFF) ; return a | b | c | d ;&#125; 首先，获取 byte 数组的某一位，位移运算会自动将 byte 类型转换为 int 类型，如果为正数，高位补0，如果为负数，高位补1。 判断一个整数的奇偶性，二进制末尾为0就是偶数，为1就是奇数 1value &amp; 1 != 0 判断 n 是否是 2 的正整数冪比如 n 是这些数，2 4 8 16 32 等，以 8 为例 123n: 00001000， n-1 : 00000111n &amp; (n-1) : 00000000","categories":[{"name":"java","slug":"java","permalink":"http://yangsui.me/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yangsui.me/tags/java/"}]},{"title":"JAVA 8 学习总结","slug":"JAVA8-OverView","date":"2016-12-10T14:26:00.000Z","updated":"2017-01-26T16:01:48.000Z","comments":true,"path":"JAVA8-OverView/","link":"","permalink":"http://yangsui.me/JAVA8-OverView/","excerpt":"最近一周 JAVA8 的学习总结 Lambda 表达式 Predicate 方法: boolean test(T t)函数描述: T -&gt; boolean作用: 传入一个参数，返回一个bool结果特征化原始类型: IntPredicate, LongPredicate, DoublePredicate Consumer 方法: boolean test(T t)函数描述: T -&gt; void作用: 传入一个参数，返回一个bool结果特征化原始类型: IntPredicate, LongPredicate, DoublePredicate Function 方法: R apply(T t)函数描述: T -&gt; R作用: 传入一个参数，返回一个结果特征化原始类型: IntFunction, IntToLongFunction, IntToDoubleFunction, LongFunction, LongToIntFunction, LongToDoubleFunction, DoubleFunction, ToIntFunction, ToLongFunction, ToDoubleFunction Supplier 方法: T get()函数描述: () -&gt; T作用: 无参数传入，返回一个结果特征化原始类型: BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier","text":"最近一周 JAVA8 的学习总结 Lambda 表达式 Predicate 方法: boolean test(T t)函数描述: T -&gt; boolean作用: 传入一个参数，返回一个bool结果特征化原始类型: IntPredicate, LongPredicate, DoublePredicate Consumer 方法: boolean test(T t)函数描述: T -&gt; void作用: 传入一个参数，返回一个bool结果特征化原始类型: IntPredicate, LongPredicate, DoublePredicate Function 方法: R apply(T t)函数描述: T -&gt; R作用: 传入一个参数，返回一个结果特征化原始类型: IntFunction, IntToLongFunction, IntToDoubleFunction, LongFunction, LongToIntFunction, LongToDoubleFunction, DoubleFunction, ToIntFunction, ToLongFunction, ToDoubleFunction Supplier 方法: T get()函数描述: () -&gt; T作用: 无参数传入，返回一个结果特征化原始类型: BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier UnaryOperator 方法: T get()函数描述: T -&gt; T作用: 一元操作符， 继承Function,传入参数的类型和返回类型相同特征化原始类型: IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BinaryOperator 函数描述: (T, T) -&gt; T作用: 二元操作符， 传入的两个参数的类型和返回类型相同， 继承BiFunction特征化原始类型: IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator BiPredicate 函数描述: (L, R) -&gt; boolean BiConsumer 函数描述: (T, U) -&gt; boolean特征化原始类型: ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer BiFunction 函数描述: (T, U) -&gt; R特征化原始类型: ToIntBiFunction, ToLongBiFunction, ToDoubleBiFunction 函数式接口 函数式描述符 方法描述 特征化原始类型 Predicate\\ T -&gt; boolean boolean test(T t) IntPredicate,LongPredicate,DoublePredicate Consumer\\ T -&gt; void void accept(T t) IntConsumer,LongConsumer,DoubleConsumer Function T -&gt; R R apply(T t) IntFunction\\,IntToLongFunction,IntToDoubleFunction,LongFunction\\,LongToIntFunction,LongToDoubleFunction,DoubleFunction\\,ToIntFunction\\,ToLongFunction\\,ToDoubleFunction\\ Supplier\\ () -&gt; T T get() BooleanSupplier, IntSupplier,LongSupplier,DoubleSupplier UnaryOperator\\ T -&gt; T IntUnaryOperator, LongUnaryOperator,DoubleUnaryOperator BinaryOperator\\ (T, T) -&gt; T IntBinaryOperator,LongBinaryOperator,DoubleBinaryOperator BiPredicate\\ (L, R) -&gt; boolean boolean test(T t, U u) BiConsumer\\ (T, U) -&gt; boolean void accept(T t, U u) ObjIntConsumer\\, ObjLongConsumer\\,ObjDoubleConsumer\\ BiFunction\\ (T, U) -&gt; R R apply(T t, U u) ToIntBiFunction\\, ToLongBiFunction\\,ToDoubleBiFunction\\ 函数式接口 函数式描述符 方法描述 特征化原始类型 Predicate T -&gt; boolean boolean test(T t) IntPredicate,LongPredicate,DoublePredicate Consumer T -&gt; void void accept(T t) IntConsumer,LongConsumer,DoubleConsumer Function T -&gt; R R apply(T t) IntFunction,IntToLongFunction,IntToDoubleFunction,LongFunction,LongToIntFunction,LongToDoubleFunction,DoubleFunction,ToIntFunction,ToLongFunction,ToDoubleFunction Supplier () -&gt; T T get() BooleanSupplier, IntSupplier,LongSupplier,DoubleSupplier UnaryOperator T -&gt; T IntUnaryOperator, LongUnaryOperator,DoubleUnaryOperator BinaryOperator (T, T) -&gt; T IntBinaryOperator,LongBinaryOperator,DoubleBinaryOperator BiPredicate (L, R) -&gt; boolean BiConsumer (T, U) -&gt; boolean ObjIntConsumer, ObjLongConsumer,ObjDoubleConsumer BiFunction (T, U) -&gt; R ToIntBiFunction, ToLongBiFunction,ToDoubleBiFunction 流收集","categories":[{"name":"java","slug":"java","permalink":"http://yangsui.me/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yangsui.me/tags/java/"}]},{"title":"珍惜好每一刻","slug":"time","date":"2016-11-25T00:50:35.000Z","updated":"2016-11-25T01:17:58.000Z","comments":true,"path":"time/","link":"","permalink":"http://yangsui.me/time/","excerpt":"","text":"加油!","categories":[],"tags":[]},{"title":"java 基础 ----基本数据结构","slug":"JAVA基础--数据结构","date":"2016-11-20T06:06:00.000Z","updated":"2016-12-08T12:56:56.000Z","comments":true,"path":"JAVA基础--数据结构/","link":"","permalink":"http://yangsui.me/JAVA基础--数据结构/","excerpt":"基本数据类型 字符型(char) java 采用 unicode 编码， 使用 2 个字节表示一个字符，所以java中的一个字符是 2 个字节c 语言使用的是 ASCII 编码，一个 char 占用 1 个字节。 由于是无符号的，且 2 个字节 32 位长度，那么其范围是 0 到 65535 。 布尔类型: boolean 数值类型: 有符号数值类型，最高位表示符号位 byte : 1 字节 short : 2 字节 int : 4 字节 long : 8 字节 float : 4 字节 double : 8 字节","text":"基本数据类型 字符型(char) java 采用 unicode 编码， 使用 2 个字节表示一个字符，所以java中的一个字符是 2 个字节c 语言使用的是 ASCII 编码，一个 char 占用 1 个字节。 由于是无符号的，且 2 个字节 32 位长度，那么其范围是 0 到 65535 。 布尔类型: boolean 数值类型: 有符号数值类型，最高位表示符号位 byte : 1 字节 short : 2 字节 int : 4 字节 long : 8 字节 float : 4 字节 double : 8 字节 基本数据类型操作 左移 &lt;&lt; 左移操作特点： 丢弃最高位，0 补最低位 如果数据没有溢出，每左移动 1 位，数据相当于乘以 2 的 1 次方，移动 n 位 相当于乘以 2 的 n 次方。 右移 &gt;&gt; 右移操作：符号位不变，左边补符号位 以 -1024&gt;&gt;1为例子，数字在计算机中是以 补码 的形式保存的，我们来一步一步进行运算。 首先，-1024 的原码是这样的，int 类型 4 个字节，一共 32 位，其中最高位的一位表示符号位 110000000 00000000 00000100 00000000 然后，对原码取反，符号位不参与取反。即 -1024 的反码是这样的 111111111 11111111 11111011 11111111 接着，对反码 +1，得到补码，-1024 最终在计算机中是这么表示的 111111111 11111111 11111100 00000000 最后，进行右移操作，符号位不变，这里为负数，最高位的符号位仍然为 1 111111111 11111111 11111110 00000000 无符号右移，符号位始终补 0，那么 -1024&gt;&gt;&gt;1 的结果如下 101111111 11111111 11111110 00000000 按位与 &amp; 只有 1 &amp; 1 = 1 其它等于 0 按位或 | 只有 0 | 0 = 0 按位取反 ~ 各位 0 变 1 ， 1 变 0 按位异或 ^ 先按位或，在按位取反 相同为 0 ， 不同为 1 有符号类型转换为无符号类型下面这幅图展示了一个 byte 类型的有符号整数，如 -5 转换为一个无符号整数的过程。 注意3点： 位运算是针对整型，进行位运算的时候，除了 long 之外，其它类型会自动转换为整型。 负数在计算中以补码表示的 不同于 C，JAVA 中不存在无符号整数，都是有符号的 具体的代码实现 1234567891011121314//将 data 字节类型转换为 0 ~ 255 (0xFF 即 1 Byte)public int getUnsignedByte(byte data) &#123; return data &amp; 0xFF;&#125;//将 data 字节类型转换为 0 ~ 65535 (0xFFFF 即 1 Word)public int getUnsignedByte(short data) &#123; return data &amp; 0xFFFF;&#125;//将 data 字节类型转换为 0 ~ 4294967295 (0xFFFFFFFF 即 DWord)public long getUnsignedInt(int data) &#123; return data &amp; 0xFFFFFFFF;&#125; JDK 是怎么实现的 ？ JDK 中有 Byte.toUnsignedInt(byte x) 方法，源代码如下 12345678910111213141516171819/** * Converts the argument to an &#123;@code int&#125; by an unsigned * conversion. In an unsigned conversion to an &#123;@code int&#125;, the * high-order 24 bits of the &#123;@code int&#125; are zero and the * low-order 8 bits are equal to the bits of the &#123;@code byte&#125; argument. * * Consequently, zero and positive &#123;@code byte&#125; values are mapped * to a numerically equal &#123;@code int&#125; value and negative &#123;@code * byte&#125; values are mapped to an &#123;@code int&#125; value equal to the * input plus 2&lt;sup&gt;8&lt;/sup&gt;. * * @param x the value to convert to an unsigned &#123;@code int&#125; * @return the argument converted to &#123;@code int&#125; by an unsigned * conversion * @since 1.8 */public static int toUnsignedInt(byte x) &#123; return ((int) x) &amp; 0xff;&#125; 上面的文档说得非常清楚： 将参数进行一个无符号 int 转换， 在这个转换中，一个 int 的整数，高 24 位为 0，低 8 位的值等于原有byte 参数的值。所以，如果 byte 类型参数的值是 0 或 正数，转换为数值上相等的一个 int 值；如果 byte 类型参数的值是负数，转换的结果等于 byte 的输入值加上 2 的 8 次方，即输入值加 256。 所以，-5 转换为 int 后的值是 256 + (-5) = 251 网络协议中的报文运算 如一个 C 语言中无符号 byte 133，即 0x85 = 10000101，在 JAVA 中获取，直接输出会是个负数，要获取正确的输出，使用上面的getUnsignedByte方法。 假设某个字节的 8 位中的第 3 和第 4 位代表了某种意义，如何取出这几位? 假设这个字节的数据如下：01011010 其中第 3 和第 4 位分别是 0 1，构造这样一个数据，00110000，即保证 3 4为1，其它位和原始数据为 0 ，使用之前的数据和构造后的数据进行 与运算，得到 00010000，然后在右移 4 位就得到 3 4 位的值。 这个例子有两个重点： 与运算，只有1 和 1 相与等于 1，其它都等于 0。所以这里我们只需要在 3 4 位构造值为 1 其它位构造值为 0 就可以了。 与运算结合位移运算 JAVA 中的自动装箱声明 Integer i = 100， JAVA 编译器会做如下的语法编译 Integer.valueOf(100)，源代码如下 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; valueOf 方法会返回一个缓存值，范围是 -128 到 127 之间，包括两个端值即 -128 和 127。在指定了 JVM 参数(-XX:AutoBoxCacheMax )之后也可以缓存这个范围之外的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; JAVA 的小数问题JAVA 中的小数的问题需要注意两个问题，精确度和范围 因为使用二进制来精确表示十进制小数，如 0.1 是做不到，所以会涉及到一个精度的问题 如 long 类型的最大值在加上一个数，就会溢出了 JAVA 的大数值计算 使用 BigInteger 和 BigDecimal 来表示大整数和大浮点数类，理论上能够表示无限大的数 BigInteger 和 BigDecimal 用于精确表示大整数和小数，常用于商业计算中 BigInteger 和 BigDecimal 都是不可变的，在每进行一次运算的时候，都会产生一个新的对象，因此他们不适合大量数学运算，应尽量使用 long float double 等基本类型做科学计算和工程计算 如果需要精确计算，用 String 构造 BigDecimal，避免用 double 构造，因为有些数字用 double 根本就无法精确表示，传给 BigDecimal 的构造方法就已经不精确了。 数值比较两个 BigDecimal 的时候要使用 compareTo()，而不是 equals()。equals 认为 0.1 和 0.1相等，0.1 和 0.10 不相等；compareTo 认为都是相等的。 有时候任意精度的小数运算仍然不能表示精确结果。 如 1 除以 9，所以在进行除法运算时，BigDecimal 可以显示控制舍入 CPU Cache计算机初期是 CPU 直接和主存进行交互，后来 CPU 的运算速度越来越快，导致主存完全跟不上。这个时候在 CPU 和主存之间添加了高速缓存。下图大致描述了各级缓存的关系。 整个 Cache 被分成若干个组，每组包含若干 Cache Line，每个 Cache Line 中有 64 个字节来存储数据。所以总的 Cache 大小是 total = 分组数量 * CacheLine数量 * 单个CacheLine大小 贴一个我本机的 Cache 截图，几个术语如下 number of sets 代表有多少个分组 ways of associativity 翻译过来是组合方式，每个分组里面包含的 CacheLine 行数 coherency line size 单个 CacheLine 大小 从图中可以看到我本机 CPU 的 L1 为 32KB，每个 Cache Line 大小为 64B，每组 8 个 CacheLine，按照上面的公式计算，那么分组的结果是：32 x 1024/8 x 64 = 64，所以我本机 L1 共有 64 个分组缓存。现代 CPU 会一次性读取一个 Cache Line 大小即 64B 的数据，即使我们的程序哪怕只请求一个 Bit 的数据。我们要很好的利用这点，写出 cache friendly 的程序来。 在 C 和 JAVA 中数组在内存中是连续分配的，是面向行存储的，即如果要读取某一列的数据，那么要跨越多个数据。我们有如下的测试程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Test &#123; final int row = 1024 * 256; final int col = 16 * 32; int[][] matrix = new int[row][col]; Random r = new Random(); public Test() &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; matrix[i][j] = r.nextInt(100); &#125; &#125; &#125; public void row() &#123; long sum = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; sum += matrix[i][j]; &#125; &#125; System.out.println(\"add row:\\t\" + sum); &#125; public void col() &#123; long sum = 0; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; sum += matrix[j][i]; &#125; &#125; System.out.println(\"add col:\\t\" + sum); &#125; public static void main(String[] args) &#123; Test t = new Test(); final long start = System.currentTimeMillis(); t.row(); final long rowCost = System.currentTimeMillis() - start; System.out.println(\"add by row time cost :\\t\" + rowCost); t.col(); final long colCost = System.currentTimeMillis() - start; System.out.println(\"add by col time cost :\\t\" + colCost); System.out.println(\"performance ratio :\\t\" + (colCost * 1.0) / rowCost); &#125;&#125; 我的 JDK 版本是 1.8，运行结果如下： 12345add row: 6644125459add by row time cost : 127add col: 6644125459add by col time cost : 2394performance ratio : 18.8503937007874 我们总共进行了 134217728 次运算，分别按照行和列的方式求和，发现按照列的方式求和比行的方式 慢18倍 多。我们来分析下原因。 matrix 是一个二维数组，我们知道 JAVA 数组是以一纬的方式存储的，看上去一个二维数组像这样 123450,0 | 0,1 | 0,2 | 0,3----+-----+-----+----1,0 | 1,1 | 1,2 | 1,3----+-----+-----+----2,0 | 2,1 | 2,2 | 2,3 事实上计算机在内存中是这么存储的 10,0 | 0,1 | 0,2 | 0,3 | 1,0 | 1,1 | 1,2 | 1,3 | 2,0 | 2,1 | 2,2 | 2,3 row() 方法通过行，我们遍历整个数组是这样 12345matrix[0][0] matrix[0][1] matrix[0][2] matrix[0][3] matrix[1][0] etc... 这就意味着，我们是按照内存中的顺序有序读取 matrix 中的值，我们看看按照列读取的情形 12345matrix[0][0]matrix[1][0]matrix[2][0]matrix[3][0]matrix[4][0] 内存中的数据每次是以小块儿(Cache Line)的形式传到 CPU 里面的，通常是 64 个字节。我们这里的数据是 4 个字节的 int 类型，也就是说 Cache Line 会一次性返回 16 个连续的整数。 row() 方法 Cache Line 返回 16 个 int 类型数据 修改所有这些数据 重复 (1024 x 256 x 16 x 32)/16 次 col() 方法 Cache Line 返回 16 个 int 类型数据 修改其中一个值 重复 (1024 x 256 x 16 x 32) 次 参考 stackoverflow 的几个链接 How do cache lines work?Which of these two for loops is more efficient in terms of time and cache performanceWhy does the order of the loops affect performance when iterating over a 2D array? JAVA 数组数组在内存中是连续分配的，JAVA 中的数组是面向行存储的，即如果要读取某一列的数据，那么要跨越多个数据。","categories":[{"name":"java","slug":"java","permalink":"http://yangsui.me/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yangsui.me/tags/java/"}]},{"title":"编辑器之 tmux","slug":"tmux基础","date":"2016-11-11T06:06:00.000Z","updated":"2016-11-21T08:28:37.000Z","comments":true,"path":"tmux基础/","link":"","permalink":"http://yangsui.me/tmux基础/","excerpt":"installmac 上安装 1brew install tmux 需要使用的时候只需要在命令行输入 tmuxtmux 所有的操作都带了一个 prefix , 这也是 tmux 用起来比较麻烦的地方. 默认的 prefix 是 ctrl + b session直接在终端查看 session 相关信息 1234tmux ls 列出会话tmux attach -t session 进入某个会话tmux -r 连接上个断开的sessiontmux new -s session -d 在后台建立会话 进入 tmux 后查看 session 相关信息 123ctrl+b s 查看/切换sessionctrl+b d 离开(detach)sessionctrl+b $ 重命名当前session","text":"installmac 上安装 1brew install tmux 需要使用的时候只需要在命令行输入 tmuxtmux 所有的操作都带了一个 prefix , 这也是 tmux 用起来比较麻烦的地方. 默认的 prefix 是 ctrl + b session直接在终端查看 session 相关信息 1234tmux ls 列出会话tmux attach -t session 进入某个会话tmux -r 连接上个断开的sessiontmux new -s session -d 在后台建立会话 进入 tmux 后查看 session 相关信息 123ctrl+b s 查看/切换sessionctrl+b d 离开(detach)sessionctrl+b $ 重命名当前session windowpanel调整 pancel 的大小, 按下 ctrl + b 之后, 输入 resize-p, DULK 分别代表上下左右四个方向, 后面的数字代码要调整的大小. 1234ctrl+b :resize-p -D 2ctrl+b :resize-p -U 2ctrl+b :resize-p -L 2ctrl+b :resize-p -R 2","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yangsui.me/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"http://yangsui.me/tags/tmux/"}]},{"title":"JAVA ClassLoader","slug":"2016-11-10-2","date":"2016-11-10T14:22:22.000Z","updated":"2016-11-10T15:08:57.000Z","comments":true,"path":"2016-11-10-2/","link":"","permalink":"http://yangsui.me/2016-11-10-2/","excerpt":"","text":"java 类加载器概述要使用一个类必须要先将这个类加载到内存中, JVM 将编译后的字节码文件, 即 .class 文件加载到内存中, 并生成一个 java.lang.Class 对象. 字节码文件通常有一下来源: 本地磁盘文件系统 class 文件 JAR 包中加载 class 文件 网络地址加载 class 文件 动态编译一个 java 源文件, 并执行加载 类加载器java 中的类加载器是通过双亲委派模型来实现的, 有如下特点 类的加载过程采用委托模式实现. 某个特定的类加载器在接到加载类的请求时, 首先将加载任务委托给父类加载器, 依次递归, 如果父类加载器可以完成类加载任务, 就成功返回; 只有父类加载器无法完成此加载任务时, 才自己去加载. JVM 预定义了三种类加载器 根类加载器(Bootstrap ClassLoader). 由C++实现, 负责将&lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中, 如 rt.jar 扩展类加载器(Extension ClassLoader). 负责将 &lt;Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir指定位置中的类库加载到内存中. 开发者可以直接使用标准扩展类加载器. 系统类加载器(System ClassLoader). 负责将系统类路径（CLASSPATH）中指定的类库加载到内存中. 开发者可以直接使用系统类加载器。","categories":[],"tags":[]},{"title":"linux 基础命令","slug":"2016-11-10-1","date":"2016-11-10T10:54:01.000Z","updated":"2016-11-10T10:55:34.000Z","comments":true,"path":"2016-11-10-1/","link":"","permalink":"http://yangsui.me/2016-11-10-1/","excerpt":"","text":"topfree","categories":[],"tags":[]},{"title":"Nginx 复习","slug":"nginx基础","date":"2016-11-10T06:23:35.000Z","updated":"2016-11-12T08:51:16.000Z","comments":true,"path":"nginx基础/","link":"","permalink":"http://yangsui.me/nginx基础/","excerpt":"","text":"WHY对自己学习 nginx 的一个总结, 能熟练使用和配置 nginx , 熟悉相关知识和原理. 安装 基本安装和配置文件位置 我这里使用的是 openresty, 我使用的是 ubuntu 安装非常简单, 具体请参考 openresty官网 执行 ./configure 之后可以看到 12345678910111213nginx path prefix: &quot;/usr/local/openresty/nginx&quot;nginx binary file: &quot;/usr/local/openresty/nginx/sbin/nginx&quot;nginx modules path: &quot;/usr/local/openresty/nginx/modules&quot;nginx configuration prefix: &quot;/usr/local/openresty/nginx/conf&quot;nginx configuration file: &quot;/usr/local/openresty/nginx/conf/nginx.conf&quot;nginx pid file: &quot;/usr/local/openresty/nginx/logs/nginx.pid&quot;nginx error log file: &quot;/usr/local/openresty/nginx/logs/error.log&quot;nginx http access log file: &quot;/usr/local/openresty/nginx/logs/access.log&quot;nginx http client request body temporary files: &quot;client_body_temp&quot;nginx http proxy temporary files: &quot;proxy_temp&quot;nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;nginx http scgi temporary files: &quot;scgi_temp&quot; 执行 make &amp;&amp; make install 安装, 安装完成最后一行有如下提示, 我们可以直接执行 openresty 命令. 1ln -sf /usr/local/openresty/nginx/sbin/nginx /usr/local/openresty/bin/openresty 设置环境变量 为了后面启动 OpenResty 的命令简单一些, 不用在 OpenResty 的安装目录下进行启动, 修改环境变量添加一下内容 123sudo vim /etc/profileexport PATH=/usr/local/openresty/nginx/sbin:$PATHsource /etc/profile 非 root 用户启动 我这里使用自己创建的 admin 账户启动 nginx 报错 123admin@iZ2zecl4i8oy1qsj9vq9ivZ:/usr/local/openresty/bin$ ./openrestynginx: [alert] could not open error log file: open() &quot;/usr/local/openresty/nginx/logs/error.log&quot; failed (13: Permission denied)2016/11/10 15:08:48 [emerg] 9765#0: mkdir() &quot;/usr/local/openresty/nginx/client_body_temp&quot; failed (13: Permission denied) 为了方便普通用户执行一些特权命令, SUID/SGID程序允许普通用户以root身份暂时执行该程序,并在执行结束后再恢复身份 需要设置下 1sudo chmod u+s nginx nginx 命令启动 1nginx 平滑启动 12nginx s- reloadkill -HUP `cat /usr/local/openresty/nginx/logs/nginx.pid` 检查 nginx.conf 配置文件是否正确 12nginx -tnginx -t /usr/local/openresty/nginx/conf 停止 nginx 1nginx -s stop 正向代理和反向代理一般来说大家通常说的代理指的是正向代理(forward proxy), 正向代理和反向代理(reverse proxy)的区别如下图: 参考 正向代理和反向代理 一句话总结: 12正向代理: 代理端 代理的是 客户端反向代理: 代理端 代理的是 服务端 nginx 做为反向代理服务器配置 nginx 作为 lb 的配置 nginx 做负载均衡, 后端其中一个 upstream 挂掉 nginx 并不知道, 需要配置, 参考如下链接 http://serverfault.com/questions/480241/nginx-failover-without-load-balancinghttp://serverfault.com/questions/140990/nginx-automatic-failover-load-balancing 需要设置: 12proxy_next_upstreamproxy_connect_timeout 具体设置方式参考nginx官方文档http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream 打发打发","categories":[],"tags":[]},{"title":"JVM 学习笔记","slug":"JVM学习笔记","date":"2016-10-26T14:23:35.000Z","updated":"2017-01-29T15:49:35.000Z","comments":true,"path":"JVM学习笔记/","link":"","permalink":"http://yangsui.me/JVM学习笔记/","excerpt":"","text":"JVM 的基本结构下图是 JVM 执行流程的基本介绍 ClassLoader 负责将编译后的 Class文件加载到内存当中, JVM 的内存模型将内存空间分为 方法区 JAVA堆 JAVA栈 本地方法区 虚拟机运行时, 需要记录下一条指令的地址, 就是 PC寄存器执行引擎负责执行类的代码 JAVA 内存模型 JAVA 内存模型(JMM), 指的是 JAVA 虚拟机在运行时候的内存模型。由上图我们可以看到，运行时模型，分为 线程私有 和 共享数据 ， 两大类。 我将上图重新画了一下。 PC 寄存器 每个线程拥有一个 PC 寄存器 在线程创建的时候创建 总是指向下一条指令的地址 执行本地方法的时候值为 undefined 方法区保存和装载类的元数据信息, 对类进行描述 类型的常量池 字段, 方法信息 方法字节码 方法区通常同永久区(Perm)关联在一起, 用于保存相对稳定和静止的数据 JAVA 堆堆具有以下特点: 应用系统分配的对象保存在堆区 所有线程共享堆. 也就是说在堆上分配了一个对象, 所有的线程都可以访问 对分代的 GC 来说, 堆也是分代的 JAVA 栈栈具有以下特点: 线程私有 栈由一系列帧组成(栈帧), 栈帧由三部分组成:栈帧保存一个方法的局部变量, 操作数栈, 常量池指针 每一个方法调用都会创建一个帧, 并压栈 JVM 的运行机制","categories":[],"tags":[]},{"title":"redis基础(安装和安全设置)","slug":"redis基本安装和安全设置","date":"2016-10-26T14:23:35.000Z","updated":"2016-11-21T08:29:05.000Z","comments":true,"path":"redis基本安装和安全设置/","link":"","permalink":"http://yangsui.me/redis基本安装和安全设置/","excerpt":"redis基本操作安装推荐通过源代码安装, 我这里是测试使用 apt-get 安装 123sudo apt-get update sudo apt-get upgradesudo apt-get -y install redis-server","text":"redis基本操作安装推荐通过源代码安装, 我这里是测试使用 apt-get 安装 123sudo apt-get update sudo apt-get upgradesudo apt-get -y install redis-server 安全配置安装之后的配置文件在 /etc/redis目录下, 需要做一些安全性的配置 bind 指令不能绑定除本地网卡ip外的其他ip. 也就是说, 不能通过bind外部主机的ip来允许外部主机的访问, 这只能通过防火墙来实现 1bind 127.0.0.1 我这里是测试使用, 会修改 ip 地址 修改端口 这个步奏不是必须 1port 6379 设置密码 redis的执行效率非常快, 外部设备每秒可以测试相当多数量的密码, 所以密码要尽量长尽量复杂redis的密码是明文存储在redis.conf文件, 因此不需要管理员记住, 所以可以使用相当长的密码. 密码验证的目标是提供第二层的安全保障. 这样当防火墙失效的话, 外部主机在没有密码的情况下仍然不能访问redis. 1requirepass your-password 指令重命名 将一些高危的指令重命名为难以猜出的名字，或者直接重命名为空字符串&quot;&quot;来禁用该指令 123456789# 重命名CONFIG指令rename-command CONFIG XXX_CONFIG# 禁用FLUSHALL指令rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB &quot;&quot;# 禁用EVAL指令rename-command EVAL &quot;&quot; 修改redis运行账户 新建一个无登陆权限的redis用户, 然后修改redis目录的所有者, 最后使用sudo -u redis来执行redis命令 12useradd -s /sbin/nologin redissudo -u redis /usr/local/bin/redis-server /etc/redis/redis.conf 登录命令使用 redis-cli 命令登录 1redis-cli -h 127.0.0.1 -p 6333 -a mypassword -h 指定主机-p 指定端口-a 指定密码 登录时候也可以不指定密码, 而在执行的时候进行认证 123redis-cli -h 127.0.0.1 -p 6333127.0.0.1:6379&gt;auth mypasswordOK","categories":[],"tags":[]},{"title":"为什么String类被设计为不可变","slug":"2016-10-13","date":"2016-10-22T12:12:35.000Z","updated":"2016-11-06T06:45:04.000Z","comments":true,"path":"2016-10-13/","link":"","permalink":"http://yangsui.me/2016-10-13/","excerpt":"","text":"翻译 为什么 String 被设计成不可变的在 JAVA 中 String 被设计为不可变, 也就是说 String 类的实例不能被修改。实例被创建的时候, 实例中所有的信息也被一并初始化好了, 所有的这些信息都不能再被修改. 不可变类有许多优点. 一个好的答案体现在对内存, 并发, 数据结构等的理解. 字符串池的要求 字符串常量池存储于 JVM 的方法区. 当创建一个字符串的时候, 如果一个字符串已经在常量池中存在, 会返回字符串的引用而不是在重新创建一个字符串 缓存 hashcode String 的 hashcode 方法在 JAVA 中被频繁的被使用, 比如 HashMap. 不可变可以保证 hashcode 总是一样的, 这样能够被缓存而不必担心改变. 也就是说, 没有必须在每次使用的时候都去计算一次 hashcode. 这样效率更高. 在 String 类中, 有这样的代码 12/** Cache the hash code for the string */private int hash; // Default to 0 促进使用其它相关的对象 参考下面的例子 12345678HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add(new String(\"a\"));set.add(new String(\"b\"));set.add(new String(\"c\")); for(String a : set)&#123; a.value = \"a\";&#125; 上面的例子中, 如果 a 是可变的, 那么就违背了集合的设计(set 表示集合中包含不重复的元素), 上面的例子是为了简单起见而设计的, 事实上 String 类中并不存在 value 这个字段. 安全 String 被广泛地用着其它类的参数, 比如: 网络连接, 文件创建等等. 如果 String 是可变的, 一个连接或是文件就能够被改变, 这样会导致很严重的安全问题. 方法认为它连接上了一台机器, 但是事实上不是. 字符串作为参数的时候, 可变的字符串在反射的时候也可能引起安全问题. 不可变对象天然是线程安全的 因为不可变对象不能被改变, 他们能够在多线程之间被共享, 这就消除了执行同步的要求. 简而言之, 因为安全和效率的原因 String 类被设计为不可变. 参考: http://www.programcreek.com/2013/04/why-string-is-immutable-in-java/","categories":[],"tags":[]},{"title":"RESTful简单介绍","slug":"关于restful api设计的一些探讨","date":"2016-06-08T07:34:35.000Z","updated":"2016-06-08T09:36:26.000Z","comments":true,"path":"关于restful api设计的一些探讨/","link":"","permalink":"http://yangsui.me/关于restful api设计的一些探讨/","excerpt":"RESTful介绍本文主要包含以下内容: 为什么要用RESTful RESTful的定义 RESTful的五个关键内容 资源与URI(Resource URI) 统一资源接口(Uniform Interface) 资源的表述 (Representation) 状态的转移 (State Transfer) 超文本驱动 (Hypertext Driven) 简单比较下REST和RPC两种API调用风格 需要注意的是本文只对RESTful进行简单的介绍, 很多内容可探讨的就比较多, 比如安全及授权, 超文本驱动, 所以只对这些内容做简单介绍. 另外文章中的很多内容在实际开发中会有所取舍, 因此本文不是实际开发中的规范, 但是对理解规范是有很大作用的. 另外, 权衡各方面利弊后, 我们会在短期内给出相应的开发规范. 文中出现的错误或表述不清楚的地方, 欢迎大家指正.","text":"RESTful介绍本文主要包含以下内容: 为什么要用RESTful RESTful的定义 RESTful的五个关键内容 资源与URI(Resource URI) 统一资源接口(Uniform Interface) 资源的表述 (Representation) 状态的转移 (State Transfer) 超文本驱动 (Hypertext Driven) 简单比较下REST和RPC两种API调用风格 需要注意的是本文只对RESTful进行简单的介绍, 很多内容可探讨的就比较多, 比如安全及授权, 超文本驱动, 所以只对这些内容做简单介绍. 另外文章中的很多内容在实际开发中会有所取舍, 因此本文不是实际开发中的规范, 但是对理解规范是有很大作用的. 另外, 权衡各方面利弊后, 我们会在短期内给出相应的开发规范. 文中出现的错误或表述不清楚的地方, 欢迎大家指正. 为什么要用RESTful为什么要用RESTful, 知乎毛草网友说得比较好 我倒不是说一定要把所有API按照RESTful的方式设计. 但是, 第一这个东西现在流行; 第二你设计接口的时候有规范太重要了. 第三, 等你需要优化的时候再去改某些细节的东西也不迟. 就算你不用RESTful, 那也要制定一套完整的规范才行. 否则以后会死的. 这也是RPC最大的问题. 自由是自由, 可是这种自由是以未来维护的复杂度作为代价的. 都不用多,你的系统运行个半年, 再维护的时候就已经会死人了好不好. 当然RESTful的优点不仅仅在于此, 大致说来有如下的优点, 会逐步在全文体现. 规范. 统一的架构风格, 使得开发 测试 运维工作变得统一. 良好的符合”RESTful风格”的URI设计,可以让Web接口的功能和整体结构更加清晰, 仅仅通过URI就能方便的推测出来接口是做什么的, 以及多个资源之间关联性同时带来更好的兼容性. 语义. 充分利用 HTTP 协议本身语义, 对资源的操作正好对应相应的HTTP动词. 安全. 由于采用的是HTTP动词的操作, 请求所造成的影响明确, 或者说副作用明确,比如GET肯定是安全的, PUT和DELETE肯定是幂等的. 无状态. 在调用一个接口（访问、操作资源）的时候, 可以不用考虑上下文, 不用考虑当前状态, 极大的降低了复杂度 RESTful定义Wikipedia的解释是这样 表述性状态转移（英文：Representational State Transfer, 简称REST）是Roy Fielding博士于2000年在他的博士论文中提出来的一种软件架构风格. Roy Fielding是 HTTP 规范的主要编写者之一. 他在论文中提到: “我这篇文章的写作目的, 就是想在符合架构原理的前提下, 理解和评估以网络为基础的应用软件的架构设计, 得到一个功能强、性能好、适宜通信的架构. REST指的是一组架构约束条件和原则.” 如果一个架构符合REST的约束条件和原则, 我们就称它为RESTful架构. REST本身并没有创造新的技术、组件或服务, 而隐藏在RESTful背后的理念就是使用Web的现有特征和能力, 更好地使用现有Web标准中的一些准则和约束. 虽然REST本身受Web技术的影响很深, 但是理论上REST架构风格并不是绑定在HTTP上, 只不过目前HTTP是唯一与REST相关的实例. 所以我们这里描述的REST也是通过HTTP实现的REST. 表述性状态转移, 这是个什么鬼, 按照覃超的说法, 其实是主语被去掉了, 全称其实是Resource Representational State Transfer, 即:资源在网络中以某种表现形式进行状态变化. 结合RESTful原则, 围绕资源, 分别从资源的定义, 获取, 表述, 关联, 状态变迁进行讨论, 主要讨论以下五个内容. 资源与URI(Resource URI) 统一资源接口(Uniform Interface) 资源的表述 (Representation) 状态的转移 (State Transfer) 超文本驱动 (Hypertext Driven) 资源与URI(Resource AND URI)资源的定义任何事物, 只要有被引用到的必要, 它就是一个资源. 资源可以是实体(例如手机号码), 也可以只是一个抽象概念(例如价值). 从消费者的观点看, 资源可以是消费者能够与之交互已达成目标的任何东西. 比如买书的发票, 订单, 用户的个人信息等等. 标识符对一个资源的访问, 总是通过资源的表述方式来间接的完成的. 资源要被使用, 必须能够在网络上标识它, 同时还需要有某些手段来操作资源. 在WEB中我们使用URI来唯一标识一个资源, 使得该资源在WEB上可寻址, 且能够使用协议来操作. 一个资源的URI将它与任何其它资源分开, 可以通过这个URI来与其它资源交互. 一个典型的RESTful URI可能是这样 1https://www.jiabangou.com/v0.1/&#123;resource&#125;/&#123;resource-id&#125;/&#123;sub-resource&#125;/&#123;sub-resource-id&#125;/&#123;sub-resource-property&#125; 以spring boot为例, github是这样设计的 1234https://github.com/spring-projectshttps://github.com/spring-projects/spring-boothttps://github.com/spring-projects/spring-boot/issueshttps://github.com/spring-projects/spring-boot/issues?q=is%3Aclosed URI的设计要遵循可读性, 可寻址的一些原则. URI代表资源的路径(位置), 以及一些特殊的操作 使用名词, 复数进行资源命名, 不管资源返回单个还是多个 单词使用小写字母, 数字, 多个单词间使用中划线(-)或下划线(_) 资源路径从父路径到子路径在到下一级路径, 所有资源放到一域名下 在资源路径之前, 使用版本号. 也有的是将版本号放到Header中, 如github. 使用?来进行来进行资源的条件过滤, 如分页 使用, 或 :来表示同级资源关系 优先使用内容协商来区分表述格式, 而不是使用后缀来区分表述格式 建议使用SSL 关于资源和URI的关系, 一句话总结是: URI唯一标识网络上的一个资源, 资源的消费者和资源的发布方通过内容协商确定返回响应的表述形式. 考虑下面的URI 1GET: http://www.jiabangou.com/users/1 users/1 代表用户资源, 该用户ID为1, http://www.jiabangou.com/users/1是URI 请求上面的URI会返回资源users/1的表现形式, 表现形式是资源的一组属性的集合, user.name user.mobile user.password 资源的表述支持各种格式, 如xml json html, URI可以将资源映射到一种具体的表述形式上. 如: http://www.jiabangou.com/users.json http://www.jiabangou.com/users.xml 对于每一个资源表述是否需要指定格式, 有待大家讨论.「rest实战」的作者认为 URI对于消费者来说应该是不透明的, 只有URI的发布者才知道如何来解释它和将它应映射到一个资源. 使用类似xml .html 或 .json的扩展名是一个历史性约定, 来自WEB服务器简单地将URI映射到文件的古老时代. 统一资源接口(Uniform Interface)RESTful架构遵循统一接口原则, 统一接口包含了一组受限的预定义的操作, 不论什么样的资源, 都是通过使用相同的接口进行资源的访问. 接口应该使用标准的HTTP方法如GET, PUT, PATCH和POST, 并遵循这些方法的语义. 如果按照HTTP方法的语义来暴露资源, 那么接口将会拥有安全性和幂等性的特性, 关于HTTP幂等后面在进行讨论. 简言之: RESTful必须通过统一的接口来对资源执行各种操作, 对于每个资源只能执行一组有限的操作. 以HTTP/1.1协议为例, HTTP/1.1协议定义了一个操作资源的统一接口, 主要包括以下内容, 后文会一一介绍. HTTP方法(GET POST PUT DELETE PATCH HEAD OPTIONS) HTTP头信息 HTTP响应信息 内容协商机制 缓存机制 安全认证机制 请求方法语义方法的说明, 关于幂等后面会专门介绍. 方法名称 是否幂等 是否安全 备注 OPTIONS 是 是 使用该方法来获取资源支持的HTTP方法列表. 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法, 该方法会用’*’来代替资源名称, 向服务器发送OPTIONS请求, 可以测试服务器功能是否正常 HEAD 是 是 用于只获取请求某个资源返回的头信息 GET 是 是 用于从服务器获取某个资源的信息 完成请求后返回状态码 200 OK 完成请求后需要返回被请求的资源详细信息 POST 否 否 用于创建新资源 创建完成后返回状态码 201 Created 完成请求后需要返回被创建的资源详细信息 PUT 是 否 用于完整的替换资源或者创建指定身份的资源, 比如创建id为123的某个资源 如果是创建了资源, 则返回 201 Created 如果是替换了资源, 则返回 200 OK * 完成请求后需要返回被修改的资源详细信息 PATCH 否 否 用于局部更新资源 完成请求后返回状态码 200 OK 完成请求后需要返回被请求的资源详细信息 DELETE 是 否 用于删除某个资源, 有的客户端不支持, 服务器端和客户端相互妥协, 如客户端通过隐藏的参数_method=DELETE来 * 完成请求后返回状态码 204 No Content 需要注意的是, 有的客户端并不支持所有的HTTP方法, 如PUT或DELETE方法. 解决办法是客户端通过提交一个隐藏的_method=PUT字段来传递真实的请求方法. 而某些JS框架, 通过设置X-HTTP-Method-Override 这个HTTP Header来避免这个问题. 以mobile项目为例, 陈老师写的处理PUT方法的例子, 注意headers部分. 1234567891011121314151617181920 /** * 发起一个PUT请求 * @param url * @param formData * @returns Promise */function put(url, jsonData) &#123; return $.ajax(&#123; url: HOST + url, type: &apos;PUT&apos;, contentType: &apos;application/json&apos;, data: JSON.stringify(jsonData), cache: false, timeout: TIMEOUT, headers: &#123; &apos;X-HTTP-Method-Override&apos;: &apos;PUT&apos;, &apos;X-Xsrftoken&apos;: Cookie.get(&apos;_xsrf&apos;) &#125; &#125;).then(responseFilter);&#125; 状态码使用HTTP动词对资源进行操作, 常见的HTTP状态码含义如下. 关于HTTP状态码及含义请参考wikipedia上的详细介绍 请求成功 2XX 200 OK : 请求执行成功并返回相应数据, 如 GET 成功 201 Created : 对象创建成功并返回相应资源数据, 如 POST 成功; 创建完成后响应头中应该携带头标 Location, 指向新建资源的地址 202 Accepted : 接受请求, 但无法立即完成创建行为, 比如其中涉及到一个需要花费若干小时才能完成的任务. 返回的实体中应该包含当前状态的信息, 以及指向处理状态监视器或状态预测的指针, 以便客户端能够获取最新状态. 204 No Content : 请求执行成功, 不返回相应资源数据, 如 PATCH DELETE 成功 重定向 3XX重定向的新地址都需要在响应头 Location 中返回 301 Moved Permanently : 被请求的资源已永久移动到新位置 302 Found : 请求的资源现在临时从不同的 URI 响应请求 303 See Other : 对应当前请求的响应可以在另一个 URI 上被找到, 客户端应该使用 GET 方法进行请求 304 Not Modified : 资源自从上次请求后没有再次发生变化, 主要使用场景在于实现数据缓存 307 Temporary Redirect : 对应当前请求的响应可以在另一个 URI 上被找到, 客户端应该保持原有的请求方法进行请求 客户端错误 4XX 400 Bad Request : 请求体包含语法错误 401 Unauthorized : 需要验证用户身份, 如果服务器就算是身份验证后也不允许客户访问资源, 应该响应 403 Forbidden 403 Forbidden : 服务器拒绝执行 404 Not Found : 找不到目标资源 405 Method Not Allowed : 不允许执行目标方法, 响应中应该带有 Allow 头, 内容为对该资源有效的 HTTP 方法 406 Not Acceptable : 服务器不支持客户端请求的内容格式, 但响应里会包含服务端能够给出的格式的数据, 并在 Content-Type 中声明格式名称 409 Conflict : 请求操作和资源的当前状态存在冲突。主要使用场景在于实现并发控制 412 Precondition Failed : 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。主要使用场景在于实现并发控制 服务器端错误 5XX 500 Internal Server Error : 服务器遇到了一个未曾预料的状况, 导致了它无法完成对请求的处理 501 Not Implemented : 服务器不支持当前请求所需要的某个功能 502 Bad Gateway : 作为网关或者代理工作的服务器尝试执行请求时, 从上游服务器接收到无效的响应 503 Service Unavailable : 由于临时的服务器维护或者过载, 服务器当前无法处理请求. 这个状况是临时的, 并且将在一段时间以后恢复. 如果能够预计延迟时间, 那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间（内容可以为数字, 单位为秒; 或者是一个 HTTP 协议指定的时间格式）. 如果没有给出这个 Retry-After 信息, 那么客户端应当以处理 500 响应的方式处理它. 上面花了大量的篇幅来介绍请求的方法和返回的状态码. 统一资源接口要求使用标准的HTTP方法对资源进行操作, 所以URI只应该来表示资源的名称, 而不应该包括资源的操作. 即: URI不应该使用动作来描述. 一组典型的HTTP动词操作可能是这样 123456GET https://www.jiabangou.com/v0.1/users 获得用户列表GET https://www.jiabangou.com/v0.1/users/&#123;id&#125; 获得指定的用户POST https://www.jiabangou.com/v0.1/users 创建一个用户PUT https://www.jiabangou.com/v0.1/users/&#123;id&#125; 更新指定的用户（提供该用户的全部信息）PATCH https://www.jiabangou.com/v0.1/users/&#123;id&#125; 更新指定的用户（提供该用户的部分信息）DELETE https://www.jiabangou.com/v0.1/users/&#123;id&#125; 删除指定的用户 来个练习题放松下, 既然URI中不能出现动词, 那么登录的URI该怎么设计呢? /login 要设计成什么样才合适呢? 同样的问题, 重设密码 /resetPassword 应该设计成什么样呢? 12/login --&gt; POST:/session/resetPassword ---&gt; PUT/PATCH: /users/:id/password HTTP幂等(Idempotence)上面反复提到幂等, 那么什么是幂等, REST中的幂等又是个什么概念? 幂等的数学定义是: 对于单目运算, 如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的, 那么我们就称该运算是幂等的. 比如求绝对值, 在实数集中, 有abs(a)=abs(abs(a)). 具体点说, 比如求 -10 的绝对值, 求一次绝对值和求100次绝对值, 结果是相同的, 都是返回10. 对于双目运算, 则要求当参与运算的两个值是等值的情况下, 如果满足运算结果与参与运算的两个值相等，则称该运算幂等. 如求两个数的最大值max(x, y)=x. 比如 x=y=100, 无论求多少次最大值, 返回结果都是相同的. 幂等性并不属于特定的协议, 它是分布式系统的一种特性; 不论是SOA还是RESTful的Web API设计都应该考虑幂等性. GET方法幂等, 无副作用 GET方法用于获取资源, 不应该有副作用, 所以是幂等的. 比如 http://www.jiabangou.com/v1.0/users/10 这个方法获取用户id为10的信息, 只是读取用户信息, 不会改变资源状态, 不论调用多少次都无副作用. 请注意: 这里强调的是一次和N次具有相同的副作用, 而不是每次GET的结果相同. 比如获取最新新闻http://www.jiabangou.com/latest-news, 每次请求结果都会不同, 但他本身无任何副作用, 因此是幂等的. 一个有意思的讨论是, 如果一个GET操作里面包含了记录日志等操作, 算不算幂等? DELETE幂等, 有副作用 DELETE方法也是幂等的, 调用删除一个id为100的方法, 调用100次和调用1次的副作用是相同的, 就是删除这个用户 POST/PUT POST和PUT方法通常被认为是「POST表示创建资源， PUT表示更新资源」 RFC规范RFC 2616, Hypertext Transfer Protocol – HTTP/1.1, Method Definitions 对POST和PUT的定义如下 The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. POST的关键点是, as a new subordinate of the resource identified by the Request-URI in the Request-Line, 即创建一个新的资源; PUT方法强调, 如果请求的URI指向一个已有的资源, 表示更新; 如果指向的URI不存在,表示新建资源;举一个更加通俗的例子, 用户请修改profile的用户昵称, 将其修改为X, 一旦更新成功, 后续无论请求同样更新接口多少次, 不会对结果产生影响. 而恰恰相反, 一个POST方法每次都会创建一个新的资源. 关于rest的幂等, 有很多很有意思的讨论 幂等的意义幂等到底有什么用, 先来看几个需求 创建订单, 每次请求只能创建一个订单 发送短信或邮件, 每次发送只发送一条短信 即使第三方系统故障, 或是网络问题, 用户支付只扣一次钱 在分布式系统及微服务中，因为网络原因而导致调用系统未能获取到确切的结果从而导致重试，是非常常见的情景. 这种情况下, 就需要接口具有幂等性. 比如上面的第一个创建订单的问题. 至于怎么样设计幂等的方案, 又是另外一个话题. 资源的表述(Representation)资源的表述是一段对于资源在某个特定时刻的状态的描述, 可以在客户端-服务器端之间转移（交换）. 资源在外界可以有多种格式(表现形式), 同一个文本资源, 可以使用json xml text等格式; 图片资源可以使用png jpg等格式. 客户端如何获取或者说知道服务器端提供什么样的表述形式呢? 答案是HTTP内容协商. HTTP内容协商(Content Negotiation)有时候, 同一个 URL 可以提供多份不同的文档, 比如访问google首页, google需要根据语言设置显示对应的语言, 提供不同语言版本的内容. 这就要求服务端和客户端之间有一个选择最合适版本的机制, 这就是内容协商。 更为正式一点的解释是这样: 客户端和服务器端就响应的资源内容进行交涉, 然后服务器端提供给客户端最为适合的资源. HTTP 的内容协商通常的方案是: 服务端根据客户端发送的请求头中某些字段自动发送最合适的版本. 可以用于这个机制的请求头字段又分两种：内容协商专用字段（Accept 字段）、其他字段。 HTTP中关于 Accept 字段定义 HTTP请求头字段 请求说明 响应头字段 Accept 告知服务器发送何种媒体类型 Content-Type Accept-Language 告知服务器发送何种语言 Content-Language Accept-Charset 告知服务器发送何种字符集 Content-Type Accept-Encoding 告知服务器采用何种压缩方式 Content-Encoding 我们来看看访问 infoq首页的截图 Accept: */* 表示接受任何资源的MIME类型 Accept-Encoding: 可以使用gzip, deflate, sdch Accept-Language: 接受 zh-CN、en-US 和 en 三种语言,并且 zh-CN 的权重最高（q 取值 0 - 1，最高为 1，最低为 0，默认为 1）, 服务端应该优先返回语言等于 zh-CN 的版本 HTTP的响应头可能是这样 12Content-Type: text/javascriptContent-Encoding: gzip infoq这里返回的是text/plain. 表示这个文档确切的 MIME 类型是 text/javascript; 响应头没有 Content-Language 字段, 通常说明返回版本的语言正好是请求头 Accept-Language 中权重最高的那个. 服务端和客户端协商好返回资源的表现形式, 客户端通过HTTP请求头的Accept头请求特定的格式, 服务器端通过Content-Type告诉客户端资源的表述形式. 各大框架都支持内容协商, ninja中也提供了对内容协商的支持. Headers &amp;&amp; Status Code客户端需要在HTTP请求头中指定需要的格式, 我们来看看Request Header Accept: 服务器需要返回什么样的内容. 客户端要求返回xml, 而服务器端只能返回json, 那么最好返回 406 status code 406 not acceptable（RFC2616) If-Modified-Since/If-None-Match 如果客户端提供某个条件, 当这条件满足时才返回数据, 否则返回304 not modified. 客户端已经缓存了某个数据, 它只是想看看有没有新的数据时, 会用这两个header之一, 服务如果返回200是不合适的. If-Match 在对某个资源做PUT/PATCH/DELETE操作时, 服务器应该要求客户端提供If-Match头, 只有客户端提供的ETag与服务器对应资源的Etag一致, 才进行操作, 否则返回412 precondition failed. 这个头非常重要, 用Etag可以防止错误更新, 能够在一定条件下避免竞争条件. HTTP协议中, ETag主要用于:缓存和请求条件控制; 关于ETag的详细介绍, 可以参考以下 wikipedia上对 ETag HTTP ETag的介绍 google developers HTTP 缓存 infoq 使用ETags减少Web应用带宽和负载 Last-Modified保存的是资源上次修改的时间. 如果服务端没有接受到Last-Modified 和 ETag直接返回403; 如果接受到了这两个header信息, 但是没能满足先决条件返回412; 满足条件更新资源, 返回200; 流程如下图 下图列举了几乎所有的HTTP状态变迁, 由于是SVG格式转换而来, 可以下载后查看大图. 我们要尽可能的使用HTTP协议的各种响应码, 尤其是4XX和5XX系列, 4XX表示客户端传入的参数问题, 5XX表示服务端错误; 应该在HTTP错误码之下, 定义更细致的业务错误编码. 这也是我们目前使用的方式. HTTP Code: 400 HTTP Body: {code = &quot;1000&quot;， message=&quot;参数验证失败&quot;} 安全及授权访问HTTP协议是一种无状态的协议, 安全特性需要我们自己来实现. 这里只罗列三种基本的身份验证方案供大家参考, 具体细节不展开. HTTP Basic, 只有在部署了 SSL 证书的情况下才可以使用, 否则用户密码会有暴露的风险, 当然最好不要使用.HTTP基本验证 JWT (JSON WEB TOKEN) json web token draft 有个JWT的详细介绍参考JWT基本介绍以及官网的相关资源 OAUTH2 理解OAuth 2.0以及对文中 state 参数的介绍的修正 状态的转移 (State Transfer)HTTP协议是一种无状态的协议, 每次的请求都是独立的, 它的执行情况和结果与前面的请求和之后的请求是无直接关系的, 它不会受前面的请求应答情况直接影响, 也不会直接影响后面的请求应答情况. 客户端与服务端的交互必须是无状态的, 并在每一次请求中包含处理该请求所需的一切信息. 服务端不需要在请求间保留应用状态, 只有在接受到实际请求的时候, 服务端才会关注应用状态. 这种无状态通信原则, 使得服务端和中介能够理解独立的请求和响应. 在多次请求中, 同一客户端也不再需要依赖于同一服务器, 方便实现高可扩展和高可用性的服务端. RESTful的状态转移是指在客户端和服务器端之间转移（transfer）代表资源状态的表述. 通过转移和操作资源的表述, 来间接实现操作资源的目的. 超文本驱动 (Hypertext Driven)马丁大叔在他的文章中详细介绍了rest的成熟度模型. 第零级没有明确的资源概念, 只有一个URL, 只使用单个HTTP方法. 第一级, 在架构中引入rest有明确的资源概念, 存在很多URL, 只使用单个HTTP方法. 这一级会使用多个URI, 然而不同的URI只是作为不同的调用入口, 与此同时只使用同一个HTTP方法传输数据. 最常见的错误就是在URI中包含动词, 比如URI http://www.jiabangou.com/getOrder?orderId=1234，其实「资源」表示一种实体, 所以应该是名词, 动词应该放在HTTP协议中. 而与此同时URI也有可能破坏HTTP GET的安全性和幕等性，比如某个客户端在http://www.jiabangou.com/updateOrder?id=1234&amp;coffee=latte上执行GET（而不是POST）, 就能创建一笔新的咖啡订单（一个资源）, 按理来说GET请求不能改变服务的任何状态. 第二级, 每个URI代表一种资源, 支持HTTP动词有明确的资源概念, 有很多URL, 使用HTTP作为操作资源的统一接口. 这一阶段通常将对于资源的CRUD式操作分别映射到4个HTTP方法. 此时使用多个URI的话, 需要让不同的URI代表不同的资源, 同时使用多个HTTP方法操作这些资源, 例如使用POST/GET/PUT/DELET分别进行CRUD操作. 这时候HTTP头和有效载荷都包含业务逻辑, 例如HTTP方法对应CRUD操作, HTTP状态码对应操作结果的状态. 我们现在看到的大多数所谓RESTful API做到的也就是这个级别. 第二级RESTful API有如下的优点: 更加松耦合 改动RESTful API比改动RPC API更容易 更好的可伸缩性, 充分利用HTTP协议的特点 与基于HTTP的各种RPC协议相比, 对HTTP的使用更有效率 便于利用HTTP缓存 支持数据流和管道. 易于实现分层的缓存, 提高了服务器端应用的可伸缩性 有统一的设计和编程风格 测试更加容易, 可以使用各种测试工具 Postman/ Advanced REST Client curl/wget SoapUI Pro Jmeter ab/httperf/curl-loader 浏览器 最好的互操作性 基于HTTP协议本身, 几乎所有编程语言都能支持 第三级, HATEOAS, 使用超媒体（hypermedia）作为应用状态引擎大多数的RESTful api设计其实只到第二级. 在第2级的基础上，使用超媒体作为应用状态的引擎. REST 服务的要求之一就是超文本驱动, 客户端不再需要将某些接口的 URI 硬编码在代码中, 唯一需要存储的只是 API 的 HOST 地址, 能够非常有效的降低客户端与服务端之间的耦合, 服务端对 URI 的任何改动都不会影响到客户端的稳定. HATEOAS可探讨内容较多, 不做展开, 目前主流的开发框架都是支持HATEOAS的, 大家可以参考下spring的 rest-hateoas 例子. 对内网环境而已, 我们占时可以不用支持HATEOAS 内网API运行在一个可控的环境中 运行在同一个组织的边界之内 服务器端开发团队和客户端开发团队可以密切沟通 运行环境相对安全，基本上不会出现恶意的请求 内网API需要做服务治理 支持HATEOAS的RESTful API不便于做服务治理 支持HATEOAS相关的生态环境还不够成熟 通用的媒体类型尚未完全标准化, 例如Hydra Core 开发框架、开发库尚不成熟 缺少自动化测试工具 REST于RPC风格比较先对上文介绍的REST做一个简单的总结. 我们对REST可以有两种理解方式. 抽象层面: REST是一种分布式应用的架构风格 REST是一种为面向互联网的应用软件量身定制的架构风格 REST正是Web自身的架构风格, 它是Web所取得的巨大成功在技术层面的原因和理论基础 REST在Web之上是普适的, 同时适用于Web App和Web API 具体层面: REST是一种分布式应用的架构设计方法 REST有很多具体的设计原则和指导, 实战性很强 内网RESTful API要解决的问题 性能：延迟、网络传输效率 大多数情况下，建立连接所消耗的时间，与服务业务逻辑的IO操作相比非常小 可升级到HTTP/2，HTTP/2极大改善了HTTP/1.1的性能 服务治理 服务注册、服务发现 自动负载均衡 流量控制 服务质量 版本化 可在URL中加版本号 对我们来说, 服务治理的问题dubbo已经帮我们解决了. REST与RPC两种API调用风格的区别 REST对服务器端做抽象的基本单元是资源, RPC对服务器端做基本抽象的单元是过程. REST的建模是以名词为核心的, RPC的建模是以动词为核心的. RPC中没有统一接口的概念. 即使采用相同的协议, 不同的API, 设计风格可以完全不同. RPC也不支持操作语义对于中间组件的可见性. RPC中无法使用超媒体, 响应的内容只包含数据. REST中使用了超媒体后, 可以实现很大粒度的交互, 交互的效率比RPC更高 REST支持数据流和管道, RPC不支持数据流和管道. 因为使用了平台中立的消息, RPC的耦合度会比DO要小一些, 但是RPC也常常会带来客户端与服务器端的紧耦合. REST中假如使用了超媒体, 客户端与服务器端可以达到最小的耦合度. REST和RPC两种风格如何做取舍 根据服务所实现的业务逻辑变化的频繁程度 业务逻辑变化频繁，必须实现松耦合：选择REST 业务逻辑固定，变化非常少，可以接受紧耦合：选择RPC 根据对于延迟、网络传输效率、实时性的要求 必须确保低延迟、网络传输效率高、实时性：选择RPC 对延迟、网络传输效率、实时性要求不高：选择REST 根据对可伸缩性的要求 对可伸缩性要求非常高：选择REST 对可伸缩性要求不高：选择RPC 本文严重参考了以下文章: 0 HTTP状态码 1 github RESTful api设计 2 rest架构怎么生动地理解 3 什么才是真正的RESTful架构 4 HTTP头vary解释 5 幂等的数学定义 6 理解HTTP幂等 7 stackoverflow关于POST和PUT的讨论 8 高并发的核心技术-幂等的实现方案 9 rest-best-practices-managing-concurrent-updates 10 REST API 安全设计指南 11 http://www.infoq.com/cn/articles/understanding-RESTful-style/","categories":[],"tags":[]},{"title":"redis持久化","slug":"redis持久化","date":"2013-03-01T12:12:35.000Z","updated":"2016-04-30T10:10:26.000Z","comments":true,"path":"redis持久化/","link":"","permalink":"http://yangsui.me/redis持久化/","excerpt":"","text":"redis持久化reids持久化类型Redis 提供了多种不同级别的持久化方式 RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照(point-in-time snapshot) AOF 持久化记录服务器执行的所有写操作命令,并在服务器启动时,通过重新执行这些命令来还原数 据集。AOF 文件中的命令全部以 Redis 协议的格式来保存,新命令会被追加到文件的末尾。Redis 还 可以在后台对 AOF 文件进行重写(rewrite),使得 AOF 文件的体积不会超出保存数据集状态所需的 实际大小 Redis 还可以同时使用 AOF 持久化和 RDB 持久化。在这种情况下,当 Redis 重启时,它会优先使用 AOF 文件来还原数据集,因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整 RDB的优点 RDB 是一个非常紧凑(compact)的文件,它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份:比如说,你可以在最近的 24 小时内,每小时备份一次 RDB 文件,并且在每个月的每一天,也备份一个 RDB 文件。这样的话,即使遇上问题,也可以随时将数据集还原到不同的版本 RDB 非常适用于灾难恢复(disaster recovery):它只有一个文件,并且内容都非常紧凑,可以(在加 密后)将它传送到别的数据中心 RDB 可以最大化 Redis 的性能:父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程,然 后这个子进程就会处理接下来的所有保存工作,父进程无须执行任何磁盘 I/O 操作 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 RDB的缺点 如果你需要尽量避免在服务器故障时丢失数据,那么RDB不适合你。虽然 Redis 允许你设置不同的 保存点(save point)来控制保存 RDB 文件的频率,但是,因为 RDB 文件需要保存整个数据集的状态,所以它并不是一个轻松的操作。因此你可能会至少5分钟才保存一次 RDB 文件。在这种情况下, 一旦发生故障停机,你就可能会丢失好几分钟的数据 每次保存 RDB 的时候,Redis 都要 fork() 出一个子进程,并由子进程来进行实际的持久化工作。在 数据集比较庞大时,fork() 可能会非常耗时,造成服务器在某某毫秒内停止处理客户端;如果数据集 非常巨大,并且 CPU 时间非常紧张的话,那么这种停止时间甚至可能会长达整整一秒。虽然 AOF 重 写也需要进行 fork() ,但无论 AOF 重写的执行间隔有多长,数据的耐久性都不会有任何损失 我们来看看rdb的配置 保存时间的设置 # In the example below the behaviour will be to save: # after 900 sec (15 min) if at least 1 key changed # after 300 sec (5 min) if at least 10 keys changed # after 60 sec if at least 10000 keys changed save 900 1 save 300 10 save 60 10000 #60秒类超过10000个key的改变 备份失败的时候停止写入,已保持数据一致 stop-writes-on-bgsave-error yes 压缩rdb文件 rdbcompression yes rdb文件保存目录及保存文件名 dbfilename dump.rdb dir /usr/local/var/db/redis/ AOF的优点 使用AOF持久化会让Redis变得非常耐久(much more durable):你可以设置不同的fsync策略, 比如无 fsync ,每秒钟一次 fsync ,或者每次执行写入命令时fsync 。AOF 的默认策略为每秒钟fsync一次,在这种配置下,Redis仍然可以保持良好的性能,并且就算发生故障停机,也最多只会丢失一秒钟的数据(fsync 会在后台线程执行,所以主线程可以继续努力地处理命令请求) AOF文件是一个只进行追加操作的日志文件(append only log),因此对 AOF 文件的写入不需要进行seek ,即使日志因为某些原因而包含了未写入完整的命令(比如写入时磁盘已满,写入中途停机, 等等),redis-check-aof工具也可以轻易地修复这种问题 Redis可以在AOF文件体积变得过大时,自动地在后台对AOF进行重写: 重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的, 因为Redis在创建新AOF文件的过程中,会继续将命令追加到现有的AOF文件里面,即使重写过程中发生停机,现有的AOF文件也不会丢失。而一旦新AOF文件创建完毕,Redis 就会从旧AOF文件切换到新AOF文件,并开始对新AOF文件进行追加操作 **AOF文件有序地保存了对数据库执行的所有写入操作,这些写入操作以Redis协议的格式保存,因此AOF文件的内容非常容易被人读懂,对文件进行分析(parse)也很轻松。导出(export)AOF文件也非常简单:举个例子,如果你不小心执行了FLUSHALL命令,但只要AOF文件未被重写,那么只要停止服务器,移除AOF文件末尾的FLUSHALL命令,并重启Redis ,就可以将数据集恢复到FLUSHALL执行之前的状态 AOF的缺点 对于相同的数据集来说,AOF 文件的体积通常要大于 RDB 文件的体积 根据所使用的 fsync 策略,AOF 的速度可能会慢于 RDB 。在一般情况下,每秒 fsync 的性能依然非常高,而关闭 fsync 可以让 AOF 的速度和 RDB 一样快,即使在高负荷之下也是如此。不过在处理巨大的写入载入时,RDB可以提供更有保证的最大延迟时间(latency) 我们来看看AOF的配置 是否打开aof配置 appendonly no 配置aof同步方式 # The fsync() call tells the Operating System to actually write data on disk # instead to wait for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # appendfsync always #每一个变化总是写入到文件 appendfsync everysec #每一秒写入变化到文件 # appendfsync no #让操作系统自己选择写入文件的时间 配置文件名称 appendfilename &quot;appendonly.aof&quot; 如果fsync策略设置成always or everysec的时候, 一个可能的保存进程在某些linux配置下可能会阻塞IO, 这个时候可以暂停AOF # When the AOF fsync policy is set to always or everysec, and a background # saving process (a background save or AOF log background rewriting) is # performing a lot of I/O against the disk, in some Linux configurations # Redis may block too long on the fsync() call. Note that there is no fix for # this currently, as even performing fsync in a different thread will block # our synchronous write(2) call. no-appendfsync-on-rewrite no 设置aof文件重写文件的大小 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb","categories":[],"tags":[]},{"title":"vmware fusion安装vmware tools","slug":"mac上vmware_fusion虚拟机在ubuntu_14.04_lts上安装vmware_tools","date":"2013-03-01T12:12:35.000Z","updated":"2016-04-30T09:56:43.000Z","comments":true,"path":"mac上vmware_fusion虚拟机在ubuntu_14.04_lts上安装vmware_tools/","link":"","permalink":"http://yangsui.me/mac上vmware_fusion虚拟机在ubuntu_14.04_lts上安装vmware_tools/","excerpt":"mac上vmware fusion虚拟机在ubuntu 14.04 LTS上安装vmware tools首先要挂在cdrom sudo mount -t auto /dev/cdrom /mnt/cdrom 如果提示该文件夹不存在, 创建一个 sudo mkdir -p /mnt/cdrom 然后在执行上面的加载步奏, 挂载成功后会有如下的提示 mount: block device /dev/cdrom is write-protected, mounting read-only","text":"mac上vmware fusion虚拟机在ubuntu 14.04 LTS上安装vmware tools首先要挂在cdrom sudo mount -t auto /dev/cdrom /mnt/cdrom 如果提示该文件夹不存在, 创建一个 sudo mkdir -p /mnt/cdrom 然后在执行上面的加载步奏, 挂载成功后会有如下的提示 mount: block device /dev/cdrom is write-protected, mounting read-only 如果要卸载执行umount命令 sudo umount /mnt/cdrom 由于我的系统是server版本的，没有桌面环境, 所以要安装vmware tools的话, 进入刚刚挂载的cdrom sudo cp VMwareTools-9.8.4-2202052.tar.gz /tmp 为什么要cp出来,是因为我们的cdrom是readonly的，不能解压, 在/tmp下 sudo tar zxvf VMwareTools-9.8.4-2202052.tar.gz cd vmware-tools-distrib ./vmware-install.pl 然后一路next","categories":[],"tags":[]},{"title":"原码反码补码的理解","slug":"原码 反码 补码","date":"2013-03-01T12:12:35.000Z","updated":"2016-04-30T09:18:34.000Z","comments":true,"path":"原码 反码 补码/","link":"","permalink":"http://yangsui.me/原码 反码 补码/","excerpt":"转载文章原码反码补码，觉得写的非常的好 一. 机器数和真值 机器数 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000那么，这里的 00000011 和 10000011 。就是机器数。0011。如果是 -3 ，就是 10000011 。","text":"转载文章原码反码补码，觉得写的非常的好 一. 机器数和真值 机器数 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000那么，这里的 00000011 和 10000011 。就是机器数。0011。如果是 -3 ，就是 10000011 。 真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。 例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。 所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。 例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1 二. 原码, 反码, 补码的基础概念和计算方法 原码 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 也就是 [-127 , 127] 原码是人脑最容易理解和计算的表示方式. 反码 反码的表示方法: 正数的反码是其本身; 负数的反码是在其原码的基础上, 符号位不变, 其余各个位取反. [+1] = [00000001]原 = [00000001]反 [-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算. 补码 补码的表示方法是: 正数的补码就是其本身; 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 三. 为何要使用原码, 反码和补码现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同. [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 对于正数，三码都是一样。对于负数，是不同的。那么为什么有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 如:计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 在补码中我们用-128来表示-0,且-128没有对应的原码和反码。 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 所以补码的设计目的是:1.使符号位能与有效值部分一起参加运算,从而简化运算规则.2.使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、C等其他高级语言中使用的都是原码。 四.原码, 反码, 补码 再深入计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢? 将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:","categories":[],"tags":[]}]}