<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>阻塞，非阻塞，同步，异步概念理解 - 日拱一卒,功不唐捐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。
严重参考并组合了以下几篇文章。
Linux IO模式及 select、poll、epoll详解
怎样理解阻塞非阻塞与同步异步的区别
我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。">
<meta property="og:type" content="article">
<meta property="og:title" content="阻塞，非阻塞，同步，异步概念理解">
<meta property="og:url" content="http://yangsui.me/同步异步阻塞非阻塞理解/index.html">
<meta property="og:site_name" content="日拱一卒,功不唐捐">
<meta property="og:description" content="对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。
严重参考并组合了以下几篇文章。
Linux IO模式及 select、poll、epoll详解
怎样理解阻塞非阻塞与同步异步的区别
我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884639194732.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884639318890.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884639787508.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884642241215.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884644916573.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884649249894.jpg">
<meta property="og:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884650634750.jpg">
<meta property="og:updated_time" content="2017-03-02T15:09:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阻塞，非阻塞，同步，异步概念理解">
<meta name="twitter:description" content="对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。
严重参考并组合了以下几篇文章。
Linux IO模式及 select、poll、epoll详解
怎样理解阻塞非阻塞与同步异步的区别
我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。">
<meta name="twitter:image" content="http://7xlqpv.com1.z0.glb.clouddn.com/14884639194732.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">联系我</a>
        
      </nav>
      <!--

      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yangsui.me"></form>
        </div>

      </nav>
    -->

    </div>
  </div>
</header>

    <section id="main" class="outer"><article id="post-同步异步阻塞非阻塞理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      阻塞，非阻塞，同步，异步概念理解
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/同步异步阻塞非阻塞理解/" class="article-date">
  <time datetime="2017-02-02T14:26:00.000Z" itemprop="datePublished">2017-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/system/">system</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->
<p>对于阻塞，非阻塞，同步，异步这几个概念，心里知道意思，但是要仔细讲出来发现又不是那么容易。</p>
<p>严重参考并组合了以下几篇文章。</p>
<p><a href="https://segmentfault.com/a/1190000003063859#articleHeader11" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别</a></p>
<p>我们知道应用程序是跑在用户空间的，对一次 IO 访问，比如 read, 实际上是数据首先被拷贝到操作系统内核的缓冲区，然后才是从内核的缓冲区拷贝到用户空间应用程序的地址空间。所以一个 read 操作会尽力两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>在 <strong>UNIX 网络编程卷一</strong> 中列举了五种 I/O 模型。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>linux 下默认的所有的 socket 都是 阻塞的。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639194732.jpg" alt="阻塞型IO"></p>
<p>用户进程调用 recvfrom 这个系统调用。<br>内核执行IO的第一阶段，准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说<strong>数据被拷贝到操作系统内核的缓冲区中是需要一个过程的</strong>。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。</p>
<p>当内核一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除阻塞状态，重新运行。</p>
<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639318890.jpg" alt="非阻塞IO"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</p>
<p>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884639787508.jpg" alt="多路复用IO"></p>
<p><strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
</blockquote>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884642241215.jpg" alt="异步IO"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。</p>
<h2 id="几种-I-O-模型总结"><a href="#几种-I-O-模型总结" class="headerlink" title="几种 I/O 模型总结"></a>几种 I/O 模型总结</h2><p>其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884644916573.jpg" alt="IO模型比较1"></p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884649249894.jpg" alt="IO模型比较2"></p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<br>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>我们可以看到，在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。</p>
<p><img src="http://7xlqpv.com1.z0.glb.clouddn.com/14884650634750.jpg" alt="IO模型比较3"></p>
<h3 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞 非阻塞"></a>阻塞 非阻塞</h3><p>调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞IO在kernel还准备数据的情况下会立刻返回。</p>
<p>所以：</p>
<p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h3><p>同步和异步关注的是<strong>消息通信机制</strong></p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>

      
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞-I-O（blocking-IO）"><span class="toc-number">1.</span> <span class="toc-text">阻塞 I/O（blocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞-I-O（nonblocking-IO）"><span class="toc-number">2.</span> <span class="toc-text">非阻塞 I/O（nonblocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-多路复用（-IO-multiplexing）"><span class="toc-number">3.</span> <span class="toc-text">I/O 多路复用（ IO multiplexing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步-I-O（asynchronous-IO）"><span class="toc-number">4.</span> <span class="toc-text">异步 I/O（asynchronous IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几种-I-O-模型总结"><span class="toc-number">5.</span> <span class="toc-text">几种 I/O 模型总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞-非阻塞"><span class="toc-number">5.1.</span> <span class="toc-text">阻塞 非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步-异步"><span class="toc-number">5.2.</span> <span class="toc-text">同步 异步</span></a></li></ol></li></ol>
      </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/">system</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/hibernate-search-elasticsearch/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/春节期间读书计划/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">春节读书计划&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>








<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-同步异步阻塞非阻塞理解" data-title="阻塞，非阻塞，同步，异步概念理解" data-url="http://yangsui.me/同步异步阻塞非阻塞理解/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'yangsuime'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
  <!-- 多说公共JS代码 end -->
</section>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 yangsui&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>